<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[求以“孩子-兄弟链表表示的树”的度]]></title>
    <url>%2F2019%2F11%2F05%2F%E6%B1%82%E4%BB%A5%E2%80%9C%E5%AD%A9%E5%AD%90-%E5%85%84%E5%BC%9F%E9%93%BE%E8%A1%A8%E8%A1%A8%E7%A4%BA%E7%9A%84%E6%A0%91%E2%80%9D%E7%9A%84%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[写在前面结点的度：结点的子树个数 树的度：树中各个结点的度的最大值 算法思想 定义一个容量足够大的队列，存放结点指针，基于层次遍历的算法思想遍历树中各结点，定义临时变量max，n，max用于记录当前已访问结点度的最大值，n记录当前结点的度： ·若当前结点p为空，则返回度数为0； ·否则，将当前结点p入队，n置为0。若p存在孩子结点，访问第一个孩子结点，同时p的度数加一（n++）,将孩子结点入队，继续访问p的剩余孩子结点，每访问一个孩子结点，度数加一。 核心代码int getMax(Tree T)&#123; if(T==NULL) return 0; Node *Q[MaxSize],*p,*q;//定义一个容量足够大的队列，存放结点指针 int front=-1,rear=-1;//初始化队列为空 int max=0,n=-1;//max记录当前已访问结点度的最大值，n记录当前结点的度 Q[++rear]=T;//根结点入队 while(front&lt;rear)&#123; p=Q[++front];//队头元素出队 n=0;//即将开始遍历子树，此时当前结点度为0 q=p-&gt;firstchild;//q指向p的第一个孩子 while(q!=NULL)&#123; n++;//度+1 Q[++rear]=q;//孩子结点入队 q=q-&gt;nextsibling;//遍历孩子的兄弟结点（即将p所有孩子入队） &#125; max=n&gt;max?n:max;//更新当前已访问结点度的最大值 &#125; return max;&#125; 运行结果]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算二叉树深度（高度）]]></title>
    <url>%2F2019%2F09%2F09%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E8%AE%A1%E7%AE%97%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[递归算法算法思想： 当二叉树为空时，深度为0； 当二叉树只有根结点时（即左、右子树均为空），深度为1； 其他情况，求二叉树的左、右子树高度的较大值+1（根结点），即为二叉树深度。 公式如下： 核心代码：int BtreeDepth(Btree T)&#123; int DL,DR,MAX; if(T==NULL)&#123; return 0; &#125; DL=BtreeDepth(T-&gt;lchild); DR=BtreeDepth(T-&gt;rchild); MAX=DL&gt;DR?DL:DR; return MAX+1;&#125; 非递归算法算法思想：利用层次遍历的思想。主要思想是：一层一层地出队列。在每次访问完毕一层时，这时队列中存储的刚好是下一层所有的元素 。设置一个工作结点指针last，在当前层访问完毕时指向下一层的最右结点（当前层访问完毕时队列中队尾结点），每次层次遍历出队时将出队结点与last进行比较，若二者相等，表明一层访问完毕，层数加一，并让last指向下一层的最右结点，直至遍历结束。 核心代码int BtreeDepth(Btree T)&#123; if(T==NULL)&#123;//树空，则高度为0 return 0; &#125; Btree *Q[MaxSize],*p;//定义一个元素为二叉树结点且容量足够的队列 int front=-1,rear=-1;//初始时刻队列为空 int last=0,level=0;//last指向下一层的最右结点 Q[++rear]=T;//根结点入队 while(front&lt;rear)&#123; p=Q[++front];//队头元素出队/*若当前结点为最右结点：当前层遍历完毕，层数+1，并奖last指向下一层最右结点*/ if(front==last)&#123; level++; last=rear; &#125;/*层次遍历：左孩子入队*/ if(p-&gt;lchild)&#123; Q[++rear]=p-&gt;lchild; &#125;/*层次遍历：右孩子入队*/ if(p-&gt;rchild)&#123; Q[++rear]=p-&gt;rchild; &#125; &#125; return level;&#125; 拓展 计算二叉树的宽度：即求结点个数最多的那一层的结点个数，在上述非递归算法中记录层间元素最大值即可； 计算二叉树的最小高度：与非递归计算高度类似，不同之处在于若在当前层遇有叶子结点则立即停止遍历，该层即为最小高度。]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>非递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零基础学高数017：不定积分003]]></title>
    <url>%2F2019%2F04%2F21%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E9%AB%98%E6%95%B0017%EF%BC%9A%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86003%2F</url>
    <content type="text"><![CDATA[1.有理函数的积分（数三不考） 2.简单无理函数的积分 3.,三角有理式的积分]]></content>
      <categories>
        <category>数学</category>
        <category>考研</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
        <tag>考研复习</tag>
        <tag>高昆轮</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[江南大学之行]]></title>
    <url>%2F2019%2F04%2F08%2F%E6%B1%9F%E5%8D%97%E5%A4%A7%E5%AD%A6%E4%B9%8B%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[2019.4.3：出发3月末，得知清明节与广西特有节日“三月三”相连，再加上我三月三前一天一整天没课，所有，4月初将迎来一个6天长假。经过一番思考，决定趁着这假期去江苏无锡，看看自己考研的心仪学校——江南大学。4月3日中午两点，我们一行三人（好友欣和她的舍友昊）踏上了离校的出租车。由于桂林—无锡的车票有点小贵，于是我们决定先从桂林→杭州，再从杭州出发去往江苏（欣的考研学校在南京，昊并不考研，这次是去男友家玩，于是我们三人在杭州便分开了）。桂林—杭州要硬座要坐大约16个小时，杭州—无锡要坐大约三个半小小时，可能是假期的放松与愉悦，我们三人并未觉得太过漫长。 2019.4.4：抵达在历经近20个小时的硬座旅途之后，我到达了无锡。一下车也看见了实现打好招呼来接我的在无锡读书的同学键。旅途的疲惫让我没有了剩余的精力立马去往江南大学或者去景点游玩，于是就跟着同学去了他的学校参观。到达之后发现无锡的气温与桂林相差无几，但桂林时常阴雨闷热，无锡这几天阳光明媚。忘了说明，同学键也有考研的意图，并且也打算报考江南大学，在他的校园里，跟着他逛了一圈，感觉虽然比我的学校大上不少，但却少了一份诗意与秀气，毕竟桂林是全国著名的旅游城市，在山山水水方面还是优于大多数城市。随后我们在操场叙旧谈心，说了很多无关痛痒的话题，也聊了一些自己对考研的看法。之后，离开了他的学校，他带我到了附近的一条小吃街游玩，由于我真的身体疲惫，状态不佳，随便逛逛之后我们便找了一家饭馆解决了晚饭，再之后他便回到了他的学校，而我便乘地铁前往我所预订的江南大学附近的宾馆住处。 下了地铁，骑着小蓝车去往宾馆，我看着路旁的建筑与夜景，无锡这座城市与桂林相比，交通更显宽阔，当时街上行人亦所剩无几，我听着歌，吹着风，顿时感觉无比的惬意，心里想起的居然是高三那年自己也是这样在晚自习之后骑着车回家，如今三年过去，自己的变化真的挺大的，以前自己还是家人眼里的乖乖孩，整天重复这上学、做题、回家、做题，虽然当时基本上保持着学习的状态，但其实自己并不知道自己为什么学习，只知道家长老师灌输的努力学习，考上好大学，但根本不知道自己想要什么，自己该做什么，对自己的未来也没有什么憧憬与规划，如今，高考失败导致我现在决定考研，但与当时相比较，自己成长了很多，不管是外观还是内在，体验了许许多多之前二十年都没有接触过的事物，遇到了许许多多形形色色的人，更重要的是，开始明白自己想要的是什么，也开始对自己的未来有了时不时的憧憬与规划…… 带着这些思绪和一天的舟车劳顿，我在宾馆的床上沉沉地睡去…… 2019.4.5：参观第二天一早（其实也九点多了），我背着书包先去吃了顿早餐，打算然后去江南大学参观，不得不说无锡的灌汤小笼包真的好好吃，这让我在无锡呆了多少天就吃了多少顿小笼包。 吃过早餐，由于同学键打算下午过来找我，于是我便打算上午先自己逛江大。之前在网上查阅江南大学的信息时，便记住了那座极具特色的牌坊校门，于是我便舍弃了离我很近的江大南门，而直冲北门而去（结果骑了整整半个小时），到了北门之后，映入眼帘的便是那座雄伟的牌坊： 我当时的心情很复杂，既有终于见到实物的兴奋与喜悦，也夹杂着自己能否考上这座学府的担心与忧虑。怀揣着这种情绪，我缓缓走进了自己的心仪之所。 北门进去貌似是学生的公寓，看着许多男男女女在路上背着书包、骑着单车，有的神采奕奕地独自行走着，有的和好友一起说笑着边走边聊， 随后，我独自漫步在江南大学的各个角落，由于正值清明假期，所以校园里的人不多，显得格外静谧。 最后，在逛了一上午之后，我终于来到了这栋楼。 站在这栋楼下，思绪万千，自己报考的专业——软件工程就在这座学院里，自己考研成功，便是其中的一员…由于看见进出的人需要刷卡才能进入，于是打消了进入内部参观的念头，我绕着这座楼走了两三遍，多么希望，多么希望自己来年能够以一名江南大学数字媒体学院软件工程研究生的身份昂首挺胸的进入这栋楼。 我坐在这栋楼外部的楼梯上，看着它，想了很多，之前一直对自己报考什么学校摇摆不定，我感觉从现在开始，我不会再动摇了。 2019.4.6：离开在最后离开无锡之前，我再次来到了江南大学，再次在数字媒体学院这栋楼周围走了两圈。 江南大学！来年再会！ 最后，希望自己这一年能尽自己最大努力，不要胸有大志，而又碌碌无为！]]></content>
      <categories>
        <category>杂文随笔</category>
      </categories>
      <tags>
        <tag>江南大学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双向循环链表：字母表实现前后移动]]></title>
    <url>%2F2019%2F04%2F02%2F%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%EF%BC%9A%E5%AD%97%E6%AF%8D%E8%A1%A8%E5%AE%9E%E7%8E%B0%E5%89%8D%E5%90%8E%E7%A7%BB%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[问题描述要求实现用户输入一个数使得26个字母的排列发生变化，例如用户输入3，输出结果： DEFGHIJKLMNOPQRSTUVWXYZABC 同时需要支持负数，例如用户输入-3，输出结果： XYZABCDEFGHIJKLMNOPQRSTUVW 代码：实现位置的前后都能移动且数据都是连着的，当然数据结构选择双向循环链表啦。 #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; #define OK 1#define ERROR 0 typedef char ElemType;typedef int status; /*定义双向链表，前驱和后继*/typedef struct DualNode&#123; ElemType data; struct DualNode *prior; struct DualNode *next;&#125;DualNode,*DuLinkList; /*链表初始化*/status InitList(DuLinkList *L)&#123; DualNode *p,*q; int i; (*L) = (DuLinkList)malloc(sizeof(DualNode)); if (!(*L)) &#123; return ERROR; &#125; (*L)-&gt;next = (*L)-&gt;prior = NULL; p = (*L);//头结点 for (i = 0; i &lt; 26; i++)//p,q交替，实现初始化 &#123; q = (DualNode *)malloc(sizeof(DualNode)); if (!q) &#123; return ERROR; &#125; q-&gt;data = 'A'+i; q-&gt;prior = p; q-&gt;next = p-&gt;next; p-&gt;next = q; p = q; &#125; p-&gt;next = (*L)-&gt;next; (*L)-&gt;next-&gt;prior = p; return 0; &#125; void Caesar(DuLinkList *L,int i)&#123; if(i&gt;0) &#123; while(i&gt;0)&#123; (*L)=(*L)-&gt;next; i--; &#125; &#125; if(i&lt;0) &#123; while(i&gt;0)&#123; (*L)=(*L)-&gt;next; i++; &#125; &#125;&#125; int main()&#123; DuLinkList L; int i,n; InitList(&amp;L); printf("请输入一个整数："); scanf("%d", &amp;n); printf("\n"); Caesar(&amp;L, n); for (i = 0; i &lt; 26; i++) &#123; L = L-&gt;next; printf("%c", L-&gt;data); &#125; printf("\n"); return 0;&#125; 一、结构体的创建 在C语言中，实现数据结构的一种常用方法便是使用结构体（structure）其示例代码如下： &gt; struct stu &#123;&gt; int num;&gt; char ch;&gt; &#125;;&gt; struct表示创建结构体 stu为结构体名称，里面的内容是各种变量类型（可以嵌套struct），然后使用示例如下： &gt; struct stu s;&gt; scanf("%d", &amp;s.num);&gt; printf("%d\n", s.num);&gt; 第一行表示创建结构为stu的结构体s，此后访问结构体内的内容需要使用 名称.名称，比如说里面的s.num表示访问结构体s里面的num。为了方便，我们介绍typedef关键词。 二、typedef的用法 typedef的作用相当于给变量类型起别名，举个例子，long long 太长，每次都写long long很烦，我们可以简化成这样 &gt; typedef long long ll;&gt; ll b;&gt; scanf("%lld", &amp;b);&gt; printf("%lld\n", b);&gt; 那么，对于结构体我们可以这样使用 &gt; typedef struct &#123;&gt; int num;&gt; char ch;&gt; &#125; stu;&gt; stu s;&gt; scanf("%d", &amp;s.num);&gt; printf("%d\n", s.num);&gt; 这样子就可以直接用stu来创建结构体 而不需要用struct stu s;这么长一串了。 【注】:C语言给结构体定义别名用typedef关键字操作，就两种情况： 给结构体起一个别名，如： typedef struct ABC{ … }S; ——这就为结构体ABC定义了一个别名S。以后写S x;就等价于写struct ABC x;了。 给结构体指针起一个别名，如： typedef struct ABC{ … }*PS; ——这就为结构体指针ABC *定义了一个别名PS。以后写PS pt;就等价于写struct ABC pt;了。注意这里是用typedef给struct ABC{…} *起一个别名PS，而不是给struct ABC{…}起一个别名PS——后者是说不通的，起码的错误是标识符不可能以*开头！]]></content>
      <categories>
        <category>每日一道编程题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>链表</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[约瑟夫环问题]]></title>
    <url>%2F2019%2F04%2F01%2F%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题描述：N个人围成一圈，从第一个人开始报数，报到m的人出圈，剩下的人继续从1开始报数，报到m的人出圈；如此往复，直到所有人出圈。（模拟此过程，输出出圈的人的序号） [问题来历：据说著名犹太历史学家 Josephus有过以下的故事：在罗马人占领乔塔帕特后，39 个犹太人与Josephus及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。然而Josephus 和他的朋友并不想遵从。首先从一个人开始，越过k-2个人（因为第一个人已经被越过），并杀掉第k个人。接着，再越过k-1个人，并杀掉第k个人。这个过程沿着圆圈一直进行，直到最终只剩下一个人留下，这个人就可以继续活着。问题是，给定了和，一开始要站在什么地方才能避免被处决？Josephus要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，于是逃过了这场死亡游戏。] 循环单链表实现： C语言： #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef struct node&#123; int data; struct node *next;&#125;node;node *create(int n)&#123; node *current = NULL, *head,*newNode; int i = 1; head = (node*)malloc(sizeof (node )); current = head; if( 0 != n ) &#123; while( i &lt;= n ) &#123; newNode = (node *)malloc(sizeof (node)); newNode-&gt;data = i++; // 为循环链表初始化，第一个结点为1，第二个结点为2。 current-&gt;next = newNode; current = current-&gt;next; &#125; current-&gt;next = head-&gt;next;//让最后一个结点指向第一个结点（第一个结点指真正有值的第一个结点，并不是头结点，头结点并不含值） &#125; free(head); return current-&gt;next ;&#125;int main()&#123; node *create(int n); int n=41,m=3,i; node *temp;//中间变量 node *p=create(n);//既是第一个结点，也是哨兵 while(p!=p-&gt;next)&#123; for(i=1;i&lt;m-1;i++)&#123; p=p-&gt;next; &#125; printf("%d\n",p-&gt;next-&gt;data); temp=p-&gt;next; p-&gt;next=temp-&gt;next; free(temp); p=p-&gt;next; &#125; printf("%d\n",p-&gt;next-&gt;data); return 0;&#125; Java代码： class node &#123; int data; node next; node(int x) &#123; data = x; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; int n = 41, m = 3, i; node p = create(n);// 既是第一个结点，也是哨兵 node temp;// 中间变量 m%=n; while (p != p.next) &#123; for (i = 1; i &lt; m - 1; i++) &#123; p = p.next; &#125; System.out.println(p.next.data); temp = p.next; p.next = temp.next; p = p.next; &#125; System.out.println(p.next.data); &#125; private static node create(int n) &#123;// 初始化循环单链表 node current = null, head = new node(0); current = head;// 哨兵p int i = 1; if (0 != n) &#123; while (i &lt;= n) &#123; node newNode = new node(i++); current.next = newNode; current = current.next; &#125; current.next = head.next;// 令尾结点指向第一个结点（注意：是第一个结点，并非头结点） &#125; return current.next; &#125;&#125; malloc和free是C语言中申请内存空间与释放内存空间的函数。 关于 head = (node*)malloc(sizeof (node )); 的解释 sizeof (node ) 就是求 struct node 这个结构体占用的字节数。 malloc(sizeof (node )) 申请 struct node 这个结构体占用字节数大小的空间 (node*)malloc(sizeof (node )) 将申请的空间的地址强制转化为 struct node * 指针类型 head = (node*)malloc(sizeof (node )) 将那个强制转化的地址赋值给 head.]]></content>
      <categories>
        <category>每日一道编程题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>链表</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零基础学高数016：不定积分002]]></title>
    <url>%2F2019%2F03%2F30%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E9%AB%98%E6%95%B0016%EF%BC%9A%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86002%2F</url>
    <content type="text"><![CDATA[第一类换元法（凑微分法） 第二类换元法（常用于去根号） 第三类分步积分法(考频最高) 例题练习：]]></content>
      <categories>
        <category>数学</category>
        <category>考研</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
        <tag>考研复习</tag>
        <tag>高昆轮</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[登录and注册面板小练习]]></title>
    <url>%2F2019%2F03%2F28%2F%E7%99%BB%E5%BD%95%E9%9D%A2%E6%9D%BF%E5%B0%8F%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[效果如图所示 登录代码： &lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;LoginForm&lt;/title&gt; &lt;style&gt; body &#123; margin: 0; padding: 0; background: url(https://ww1.sinaimg.cn/large/007i4MEmly1g1ijjymj69j32yo1o07wh.jpg) no-repeat; background-size: cover; &#125; #LoginForm &#123; width: 300px; height: 300px; background: #000000b8; margin: auto; margin-top: 180px; border-top: 4px solid #70d5f5c7; padding: 30px; &#125; #LoginForm h6 &#123; margin: 0; color: white; font-size: 22px; text-align: center; height: 45px; border-bottom: 1px solid; margin-bottom: 30px; &#125; .nameAndPass &#123; width: 100%; color: white; border: 1px solid #61b0c9; background: #011d1d; font-size: 14px; font-weight: bold; padding: 14px 10px; margin-bottom: 10px; margin-left: -10px; &#125; #loginButt &#123; border: none; font-family: arial; margin: 0; width: 100%; background: #61b0c9; height: 40px; color: white; font-size: 16px; font-weight: bold; margin-top: 12px; margin-bottom: 35px; &#125; #LoginForm a &#123; padding: 10px; text-decoration: none; font-size: 13px; font-family: 微软雅黑; color: white; &#125; #LoginForm a:hover &#123; text-decoration: underline; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="LoginForm"&gt; &lt;h6&gt;LoginForm&lt;/h6&gt; &lt;!--placeholder 属性提供可描述输入字段预期值的提示信息（hint）。该提示会在输入字段为空时显示，并会在字段获得焦点时消失。--&gt; &lt;input class="nameAndPass" type="text" placeholder="UserName" name="UserName" value="" /&gt; &lt;input class="nameAndPass" type="password" placeholder="PassWord" name="PassWord" value="" /&gt; &lt;input id="loginButt" type="button" value="登录" /&gt; &lt;center&gt; &lt;a href="#"&gt;尚未注册&lt;/a&gt; &lt;a href="#"&gt;忘记密码&lt;/a&gt;&lt;br /&gt; &lt;a href="#"&gt;回到首页&lt;/a&gt; &lt;/center&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 注册代码： html: &lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;注册面板小练习&lt;/title&gt; &lt;link rel="stylesheet" href="css/Register.css" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="RegisterForm"&gt; &lt;h6&gt;RegisterForm&lt;/h6&gt; &lt;form action="" method="post"&gt; &lt;!--placeholder 属性提供可描述输入字段预期值的提示信息（hint）。该提示会在输入字段为空时显示，并会在字段获得焦点时消失。--&gt; &lt;input class="nameAndPassAndEmail" type="text" placeholder="UserName" name="UserName" value="" /&gt; &lt;input class="nameAndPassAndEmail" type="text" placeholder="Email" name="Email" value="" /&gt; &lt;input class="nameAndPassAndEmail" type="password" placeholder="PassWord" name="PassWord" value="" /&gt; &lt;p&gt;I agree to&lt;a href="#" id="terms"&gt;terms and conditions.&lt;/a&gt;&lt;/p&gt; &lt;input id="registerButt" type="button" value="注册" /&gt; &lt;center&gt; &lt;a href="#"&gt;已有账号&lt;/a&gt; &lt;a href="#"&gt;回到首页&lt;/a&gt; &lt;/center&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; Register.css: body &#123; margin: 0; padding: 0; background: url(https://ww1.sinaimg.cn/large/007i4MEmly1g1ijjymj69j32yo1o07wh.jpg) no-repeat; background-size: cover;&#125;#RegisterForm &#123; width: 300px; height: 320px; background: #000000b8; margin: auto; margin-top: 180px; border-top: 4px solid #70d5f5c7; padding: 30px;&#125;#RegisterForm h6 &#123; margin: 0; color: white; font-size: 22px; text-align: center; height: 45px; border-bottom: 1px solid; margin-bottom: 20px;&#125;.nameAndPassAndEmail &#123; width: 100%; color: white; border: 1px solid #61b0c9; background: #011d1d; font-size: 14px; font-weight: bold; padding: 14px 10px; margin-bottom: 10px; margin-left: -10px;&#125;#RegisterForm p &#123; float: left; color: white; font-size: 14px; margin: 0 15px 0 0;&#125;#terms &#123; color: white; font-size: 14px;&#125;#registerButt &#123; border: none; font-family: arial; margin: 0; width: 100%; background: #61b0c9; height: 40px; color: white; font-size: 16px; font-weight: bold; margin-top: 12px; margin-bottom: 10px;&#125;#RegisterForm a &#123; color: white; font-size: 14px; padding: 10px; text-decoration: none;&#125;#RegisterForm a:hover &#123; text-decoration: underline;&#125;]]></content>
      <categories>
        <category>前端工程师</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[质数的判断]]></title>
    <url>%2F2019%2F03%2F19%2F%E8%B4%A8%E6%95%B0%2F</url>
    <content type="text"><![CDATA[判断一个数是不是质数代码Java代码： import java.util.Scanner;public class Main&#123; public static void main(String[] args)&#123; Scanner cin=new Scanner(System.in); int n=cin.nextInt(); System.out.println(isPrime(n)); &#125; private static boolean isPrime(int n)&#123; boolean flag=true; for(int i=2;i*i&lt;=n;i++)&#123; if(n%i==0)&#123; flag=false; &#125; &#125; return flag; &#125; &#125; C语言代码： #include&lt;stdio.h&gt;int main()&#123; int isPrime(int); int n,flag; scanf("%d",&amp;n); flag=isPrime(n); if(flag==1) &#123; printf("%d is Prime\n",n); &#125;else &#123; printf("%d is Not Prime\n",n); &#125; &#125;int isPrime(int n)&#123; int flag=1; int i; for(i=2;i*i&lt;=n;i++) &#123; if(n%i==0) &#123; flag=-1; &#125; &#125; return flag;&#125; [注]：好久没写过C了，都忘了怎么写了，都忘了C语言中没有布尔型变量…… 讲解[关于i*i&lt;=n的讲解]：要判断n是否为质数，就从2一直尝试到n-1的做法效率是最差的！ 其实只要从2一直尝试到根号n，就可以了。因为因数都是成对出现的。比如，100的因数有：1和100，2和50，4和25，5和20，10和10。看出来没有？成对的因数，其中一个必然小于等于100的开平方，另一个大于等于100的开平方。 输出≤n(n≤10000000)的质数的个数代码Java代码 import java.util.Scanner;public class Main&#123; public static void main(String[] args)&#123; Scanner cin=new Scanner(System.in); int n=cin.nextInt(); System.out.println(fun(n)); &#125; private static int fun(int n)&#123; boolean[] flag=new boolean[n+1]; int count=0,num=2; while(num&lt;=n)&#123; if(flag[num]==false)&#123; for(int i=num*2;i&lt;=n;i+=num)&#123; flag[i]=true; &#125; count++; &#125; num++; &#125; return count; &#125;&#125; 讲解[筛法]：首先，2是公认最小的质数，所以，先把所有2的倍数去掉；然后剩下的那些大于2的数里面，最小的是3，所以3也是质数；然后把所有3的倍数都去掉，剩下的那些大于3的数里面，最小的是5，所以5也是质数……上述过程不断重复，就可以把某个范围内的合数全都除去（就像被筛子筛掉一样），剩下的就是质数了。而筛选这一步骤通过构造一个定长的布尔型容器（通常用数组）来实现，分别表示2~n的标志，若是非质数，则设为true，若是质数，则保持原状态false，最后2~n中标志为false的就全部是质数了 。]]></content>
      <categories>
        <category>每日一道编程题</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零基础学高数015：不定积分001]]></title>
    <url>%2F2019%2F03%2F17%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E9%AB%98%E6%95%B0015%EF%BC%9A%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%2F</url>
    <content type="text"><![CDATA[一.不定积分的概念、性质及存在性1.原函数与不定积分的概念2.原函数存在定理 ①连续函数必有原函数；(但非连续函数不一定没有原函数) ②含有第一类间断点或无穷间断点的函数，在包含该间断点在内的任何区间内都没有原函数. 关于定理②的证明: 3.不定积分的性质 4.基本积分公式（需熟稔于心）]]></content>
      <categories>
        <category>数学</category>
        <category>考研</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
        <tag>考研复习</tag>
        <tag>高昆轮</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速找到未知长度单链表的中间结点]]></title>
    <url>%2F2019%2F03%2F17%2F%E5%BF%AB%E9%80%9F%E6%89%BE%E5%88%B0%E6%9C%AA%E7%9F%A5%E9%95%BF%E5%BA%A6%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[腾讯面试题快速找到未知长度单链表的中间结点 一般思路 先遍历链表，获得链表的长度L 然后再次从头开始遍历，循环L/2次找到中间结点 时间复杂度：O(L+L/2) class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; ListNode curNode = new ListNode(0); ListNode node = curNode; for (int i = 1; i &lt;= 10; i++) &#123; ListNode newNode = new ListNode(i); curNode.next = newNode; curNode = curNode.next; &#125; System.out.println(fingMidNode(node)); &#125; private static int fingMidNode(ListNode node) &#123; int length=0; ListNode curNode=node; while(curNode!=null) &#123; length++; curNode=curNode.next; &#125; for(int i=0;i&lt;length/2;i++) &#123; node=node.next; &#125; return node.val; &#125;&#125; 输出结果：5 改进思路 利用快慢指针的原理：设置两个指针search和mid 一开始search和mid都指向单链表的头结点 search的移动速度是mid的两倍，即search每次移动2个结点，mid每次移动1个结点 当search指向末尾结点的时候，mid正好就指向了中间结点 算法复杂度：O(L/2) class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; ListNode curNode = new ListNode(0); ListNode node = curNode; for (int i = 1; i &lt;= 10; i++) &#123; ListNode newNode = new ListNode(i); curNode.next = newNode; curNode = curNode.next; &#125; System.out.println(fingMidNode(node)); &#125; public static int fingMidNode(ListNode n) &#123; ListNode search, mid; search = n; mid = n; while (search.next != null) &#123; if (search.next.next != null) &#123; search = search.next.next; mid = mid.next; &#125; else &#123; search = search.next; &#125; &#125; return mid.val; &#125;&#125;]]></content>
      <categories>
        <category>每日一道编程题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零基础学高数014：曲率渐近线]]></title>
    <url>%2F2019%2F03%2F16%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E9%AB%98%E6%95%B0014%EF%BC%9A%E6%9B%B2%E7%8E%87%E6%B8%90%E8%BF%91%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[这一节数一数二考查较多，尤其是数二 曲率及曲率半径（数三不考） 渐近线例题：]]></content>
      <categories>
        <category>数学</category>
        <category>考研</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
        <tag>考研复习</tag>
        <tag>高昆轮</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零基础学高数013：函数的单调性与曲线的凹凸性]]></title>
    <url>%2F2019%2F03%2F14%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E9%AB%98%E6%95%B0013%EF%BC%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8D%95%E8%B0%83%E6%80%A7%E4%B8%8E%E6%9B%B2%E7%BA%BF%E7%9A%84%E5%87%B9%E5%87%B8%E6%80%A7%2F</url>
    <content type="text"><![CDATA[1.函数单调性的判别法则(要会证明)2.曲线凹凸性的定义及判定(判定：要会证明)曲线凹凸性的另一种定义： 3.极值点及拐点的定义及判定(必要条件+充分条件：要会证明)极值点: 拐点:(必要条件+充分条件：要会证明) 如何记忆： 求函数极 值的步骤(求曲线拐点的步骤类似，只需把用到的导数抬高一阶):求函数最值的步骤： 注： 4.例题：]]></content>
      <categories>
        <category>数学</category>
        <category>考研</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
        <tag>考研复习</tag>
        <tag>高昆轮</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Add Two Numbers (链表)]]></title>
    <url>%2F2019%2F03%2F14%2FAdd-Two-Numbers-(%E9%93%BE%E8%A1%A8)%2F</url>
    <content type="text"><![CDATA[You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. 思路： 题目翻译： 您将获得两个非空链表，表示两个非负整数。数字以相反的顺序存储，每个节点包含一个数字。添加两个数字并将其作为链接列表返回。 您可以假设这两个数字不包含任何前导零，除了数字0本身。 初步思路： 【借鉴】：阶乘计算 三个链表：已知的l1与l2，以及存储结果的新链表l3 每次将l1的当前结点node1与l2的当前结点node2进行相加运算; 若计算结果位数为1，当然可以直接添加进链表3；但如果计算结果位数&gt;1怎么办呢？ 每次两结点的计算结果要么为1位，要么为2位，当位数=2时，可以写成A=a*10+r(r为A%10，a=A/10); 链表的每个结点的数据实际上=实际结果%10+上一结点相加产生的进位 不在赘述，图形化可能更能任意理解 我的初步代码： class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125; &#125;public class Solution&#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; int r=0;//每次的进位 ListNode curNode=new ListNode(0); ListNode l3=curNode; while(l1!=null||l2!=null)&#123; if(l1==null)&#123; l1=new ListNode(0); &#125; if(l2==null)&#123; l2=new ListNode(0); &#125; int result=(l1.val+l2.val)+r; curNode.next=new ListNode(result%10); curNode=curNode.next; r=result/10; l1=l1.next; l2=l2.next; &#125; return l3.next;//舍弃头结点 &#125;&#125; Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8 对于 (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)得到了正确结果，但仍然报：Wrong Answer 因为若Input: (5) + (5 )，应该得到0-&gt;1，但上述代码Output:0 因为当最后一对结点node1与node2计算若产生进位，仍然是只把计算result%10存入了链表3，而忽略了此时产生的进位，因此将上述代码改进： class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125; &#125;public class Solution&#123; public static ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; int r=0; ListNode curNode=new ListNode(0); ListNode l3=curNode; while(true)&#123; if(l1==null&amp;&amp;l2!=null)&#123; l1=new ListNode(0); &#125; if(l2==null&amp;&amp;l1!=null)&#123; l2=new ListNode(0); &#125; if(l1==null&amp;&amp;l2==null)&#123; if(r!=0) curNode.next=new ListNode(r); break; &#125; int result=(l1.val+l2.val)+r; curNode.next=new ListNode(result%10); curNode=curNode.next; r=result/10; l1=l1.next; l2=l2.next; &#125; return l3.next; &#125;&#125; 成功：Accepted 官方所给答案： class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125; &#125;public class Solution&#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummyHead = new ListNode(0); ListNode p = l1, q = l2, curr = dummyHead; int carry = 0; while (p != null || q != null) &#123; int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum % 10); curr = curr.next; if (p != null) p = p.next; if (q != null) q = q.next; &#125; if (carry &gt; 0) &#123; curr.next = new ListNode(carry); &#125; return dummyHead.next;&#125;&#125; 思路与我的基本一致，但细节上略有不同，比我的代码简洁许多，自己还是不够完善，继续学习！！！ 【题目来源】：LeetCode]]></content>
      <categories>
        <category>每日一道编程题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用两个栈实现队列]]></title>
    <url>%2F2019%2F03%2F13%2F%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目描述用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 import java.util.Stack;public class Solution &#123; Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); public void push(int node) &#123; &#125; public int pop() &#123; &#125;&#125; 思路： 栈为先进后出，队列为先进先出。 题目要求我们用两个栈实现先进先出： 选定栈1为进栈口，选定栈2为出栈口 整体思路是元素先依次进入栈1，再从栈1依次弹出到栈2，然后弹出栈2顶部的元素，整个过程就是一个队列的先进先出。 但是在交换元素的时候需要判断两个栈的元素情况：“进队列时”，队列中是否还有元素，若有，说明栈2中的元素不为空，此时就先将栈2的元素倒回到栈1 中，保持在“进队列状态”。“出队列时”，将栈1的元素全部弹到栈2中，保持在“出队列状态”。 所以要做的判断是，进时，栈2是否为空，不为空，则栈2元素倒回到栈1，出时，将栈1元素全部弹到栈2中，直到栈1为空。 import java.util.Stack;public class Solution &#123; Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); public void push(int node) &#123; while(!stack2.empty())&#123; stack1.push(stack2.pop()); &#125; stack1.push(node); &#125; public int pop() &#123; while(!stack1.empty())&#123; stack2.push(stack1.pop()); &#125; return stack2.pop(); &#125;&#125; 大神代码： import java.util.Stack; public class Solution &#123; Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); public void push(int node) &#123; stack1.push(node); &#125; public int pop() &#123; if(stack1.empty()&amp;&amp;stack2.empty())&#123; throw new RuntimeException("Queue is empty!"); &#125; if(stack2.empty())&#123; while(!stack1.empty())&#123; stack2.push(stack1.pop()); &#125; &#125; return stack2.pop(); &#125;&#125;]]></content>
      <categories>
        <category>每日一道编程题</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从尾到头打印链表]]></title>
    <url>%2F2019%2F03%2F13%2F%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目描述输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 public class ListNode {​ int val;​ ListNode next = null; ListNode(int val) {​ this.val = val; }} import java.util.ArrayList;public class Solution {​ public ArrayList printListFromTailToHead(ListNode listNode) {​ return null;​ }} 思路这道题看起来比较简单，我一开始认为直接按顺序遍历每个结点，并存入集合list，当结点为空时表示所有结点已经遍历结束，最后通过Collections.reverse(list)方法反转list中元素顺序即可。 class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125; &#125;import java.util.ArrayList;import java.util.Collections;public class Solution &#123; public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); while(listNode != null)&#123; list.add(listNode.val); listNode = listNode.next; &#125; Collections.reverse(list);//使用Collections的reverse方法，直接将list反转 return list; &#125;&#125; 结果通过，但通过浏览他人代码发现：为什么还要调用reverse呢，添加的时候直接头插法就行了啊. 数据结构单链表创建之头插法+尾插法：https://blog.csdn.net/ZXC641483573/article/details/78079732 头插法代码： class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125; &#125;import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); while(listNode != null)&#123; list.add(0,listNode.val); listNode = listNode.next; &#125; return list; &#125;&#125; 注释：以前常用的都是List的add(参数)方法，基本没用过public void add(int index,E element)方法，而且刚开始看上述头插法代码以为循环中每次list.add(0,listNode.val);都会把之前list(0)的值覆盖，通过查阅API发现： 纠正了一直以来的错误认知。 除此之外，还可借助堆栈的“后进先出”实现： class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125; &#125;import java.util.ArrayList;import java.util.Stack;public class Solution &#123; public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; Stack&lt;Integer&gt; stack=new Stack&lt;Integer&gt;(); while(listNode!=null)&#123; stack.push(listNode.val); listNode=listNode.next; &#125; ArrayList&lt;Integer&gt; list=new ArrayList&lt;Integer&gt;(); while(!stack.isEmpty())&#123; list.add(stack.pop()); &#125; return list; &#125;&#125; 参考思路：https://www.nowcoder.com/questionTerminal/d0267f7f55b3412ba93bd35cfa8e8035 众多解法中有很多采用递归求解，实质上也是利用了堆栈结构实现。]]></content>
      <categories>
        <category>每日一道编程题</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[丑数]]></title>
    <url>%2F2019%2F03%2F11%2F%E4%B8%91%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 思路丑数：只包含质因子2、3、5的数称作丑数。（说通俗点：一个数的所有因子中，为质数的因子只能是2、3、5） 关键点（难点）：丑数p = 2 ^ x * 3 ^ y * 5 ^ z； 即每个丑数都满足上述式子，只是x、y、z取值不同生成了不同的丑数， 同时得出一个丑数p1一定是由另一个小于它的丑数p2乘以2 or 乘以3 or 乘以5得到的。 如： 1是最小（也是最初的丑数），于是我们分别将1与2、3、5相乘→得到2、3、5三个丑数； 然后由2、3、5出发我们又会得到：4，6,10,6，9,15,10,15,25九个丑数； …… 但是这样得到的丑数是有重复且无序的，题目要求我们求按从小到大的顺序的第N个丑数，即要求我们得出的丑数是有序排列的（升序）。 那么： 先定义一个队列a用来存储丑数，a[0]=1; 当由1得出2、3、5三个丑数时，我们可以取新生成的丑数中最小的丑数:2，然后2加入队列a，即a={1,2}; 紧接着我们由a[1]=2与2、3、5相乘得出新丑数：4、6、10，注意：此时4并不是当前的最小丑数，不要忘了第二部生成的3和5，因此，我们可以维护3个数列； 假设有3个数列，分别为： 乘以2产生的丑数队列、 乘以3产生的丑数队列、 乘以5产生的丑数队列； （1）丑数数组： 1 *乘以2的队列：2 *乘以3的队列：3 *乘以5的队列：5 选择三个队列头最小的数2加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列； （2）丑数数组：1,2 ​ *乘以2的队列：4 ​ *乘以3的队列：3，6 ​ *乘以5的队列：5，10 ​ 选择三个队列头最小的数3加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列； （3）丑数数组：1,2,3 ​ *乘以2的队列：4,6 ​ *乘以3的队列：6,9 ​ *乘以5的队列：5,10,15 ​ 选择三个队列头里最小的数4加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列； （4）丑数数组：1,2,3,4 ​ *乘以2的队列：6，8 ​ *乘以3的队列：6,9,12 ​ *乘以5的队列：5,10,15,20 ​ 选择三个队列头里最小的数5加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列； （5）丑数数组：1,2,3,4,5 ​ *乘以2的队列：6,8,10， ​ *乘以3的队列：6,9,12,15 ​ *乘以5的队列：10,15,20,25 ​ 选择三个队列头里最小的数6加入丑数数组，但我们发现，有两个队列头都为6，所以我们弹出两个队列头，同时将12,18,30放入三个队列； ​ …………………… ​ 疑问： ​ 1.为什么分三个队列？ ​ 丑数数组里的数一定是有序的，因为我们是从丑数数组里的数乘以2,3,5选出的最小数，一定比以前未乘以2,3,5大，同时对于三个队列内部，按先后顺序乘以2,3,5分别放入，所以同一个队列内部也是有序的； ​ 2.为什么比较三个队列头部最小的数放入丑数数组？ ​ 因为三个队列是有序的，所以取出三个头中最小的，等同于找到了三个队列所有数中最小的。 ​ 实现思路： ​ 我们没有必要维护三个队列，只需要记录三个指针显示到达哪一步；“|”表示指针,arr表示丑数数组； ​ （1）1 ​ |2 ​ |3 ​ |5 ​ 目前指针指向0,0,0，队列头arr[0] * 2 = 2, arr[0] 3 = 3, arr[0] 5 = 5 ​ （2）1 2 ​ 2 |4 ​ |3 6 ​ |5 10 ​ 目前指针指向1,0,0，队列头arr[1] * 2 = 4, arr[0] 3 = 3, arr[0] 5 = 5 ​ （3）1 2 3 ​ 2| 4 6 ​ 3|6 9 ​ |5 10 15 目前指针指向1,1,0，队列头arr[1] * 2 = 4, arr[1] 3 = 6, arr[0] 5 = 5 ……………… 代码：import java.util.List;import java.util.ArrayList;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in=new Scanner(System.in); int N=in.nextInt(); int num=GetUglyNumber_Solution(N); System.out.println(num); &#125; public static int GetUglyNumber_Solution(int N) &#123; if(N&lt;=0) return 0; List&lt;Integer&gt; list=new ArrayList&lt;Integer&gt;(); list.add(1); int i1=0,i2=0,i3=0;//3个记录指针 while(list.size()&lt;N) &#123; int n1=list.get(i1)*2; int n2=list.get(i2)*3; int n3=list.get(i3)*5; int min=Math.min(n1, Math.min(n2, n3)); list.add(min); if(min==n1) &#123; i1++; &#125; if(min==n2) &#123; i2++; &#125; if(min==n3) &#123; i3++; &#125; &#125; return list.get(N-1); &#125;&#125; 运行时间：26ms 占用内存：9468k 参考思路：https://www.nowcoder.com/questionTerminal/6aa9e04fc3794f68acf8778237ba065b]]></content>
      <categories>
        <category>每日一道编程题</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零基础学高数012：泰勒公式]]></title>
    <url>%2F2019%2F03%2F10%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E9%AB%98%E6%95%B0012%EF%BC%9A%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1.定理(1主要用于求极限；2主要用于证明。此处重点掌握第一种) 2.需要背诵的公式！！！ 3.两种题型 例题： 总结：]]></content>
      <categories>
        <category>数学</category>
        <category>考研</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
        <tag>考研复习</tag>
        <tag>高昆轮</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器人的运动范围]]></title>
    <url>%2F2019%2F03%2F09%2F%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4%2F</url>
    <content type="text"><![CDATA[题目描述地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ public class Solution {​ public int movingCount(int threshold, int rows, int cols)​ { ​ } } 思路题中所给代码movingCount(int threshold, int rows, int cols)方法参数含义： int threshold：行坐标和列坐标的数位之和不能&gt;threshold int rows, int cols：矩形的行列数 首次进入方格矩形，横纵坐标：（0，0） 对所进方格进行判断： ①x和y是否正确； ②当前格子的flag是true还是false(true表示走过)； ③当前格子的行坐标和列坐标的数位之和与threshold进行大小比较； 若上述三点任一点不满足，则返回0。 若符合条件，则将该方格标记为true,表示已经走过 对该方格左右上下四个方向的相邻格子进行递归判断； 将四个方向遍历的返回结果进行相加，再加上1（一开始进入(0,0)坐标），即为机器人能够达到格子数。 我的代码： import java.util.Scanner;public class Solution &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int rows = in.nextInt(); int cols = in.nextInt(); int threshold = in.nextInt(); System.out.println(movingCount(threshold, rows, cols)); &#125; public static int movingCount(int threshold, int rows, int cols) &#123; boolean[][] flag = new boolean[rows][cols];// 记录是否走过:false表示未走过 return find(0, 0, rows, cols, threshold, flag); &#125; private static int find(int x, int y, int rows, int cols, int k, boolean[][] flag) &#123; if (x &lt; 0 || y &lt; 0 || x &gt;= rows || y &gt;= cols || flag[x][y] || getSum(x) + getSum(y) &gt; k) return 0; flag[x][y] = true; return find(x - 1, y, rows, cols, k, flag) + find(x + 1, y, rows, cols, k, flag) + find(x, y - 1, rows, cols, k, flag) + find(x, y + 1, rows, cols, k, flag)+1; &#125; private static int getSum(int number) &#123; int sum = 0; while (number &gt; 0) &#123; sum += number % 10; number /= 10; &#125; return sum; &#125;&#125; 【相似题目】：矩阵中的路径 更多巧妙解法 更多解法中还有许多自己目前难以理解的解法思路，希望自己能经常观看，早日理解！！！]]></content>
      <categories>
        <category>每日一道编程题</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零基础学高数011：洛必达法则]]></title>
    <url>%2F2019%2F03%2F09%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E9%AB%98%E6%95%B0011%EF%BC%9A%E6%B4%9B%E5%BF%85%E8%BE%BE%E6%B3%95%E5%88%99%2F</url>
    <content type="text"><![CDATA[定理： [注]：运用洛必达法则，必须同时满足上述三个条件，缺一不可！！！解题过程中常常看到满足（1）就直接运用洛必达法则，这种情况很有可能因并未满足（2）（3）而落入陷阱。 【例子】： 这道题一定要搞懂！！！ 例题：]]></content>
      <categories>
        <category>数学</category>
        <category>考研</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
        <tag>考研复习</tag>
        <tag>高昆轮</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[结绳]]></title>
    <url>%2F2019%2F03%2F08%2F%E7%BB%93%E7%BB%B3%2F</url>
    <content type="text"><![CDATA[思路： 绳子每进行一次连接就要对折一次，长度就会减少一半，那么应该让较长的绳子尽量少对折。按照这样的想法，那么应该将绳子从小到大排列，两两进行串连。 所以每次选取最小得绳子和第二小得绳子进行对折即可。 代码v1.0: import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); int N = in.nextInt(); for (int i = 0; i &lt; N; i++) &#123; list.add(in.nextInt()); &#125; int max = f(list); System.out.println(max); &#125; private static int f(List&lt;Integer&gt; list) &#123; if (list.size() == 1) &#123; return list.get(0); &#125; Collections.sort(list); list.add((list.get(1) + list.get(0)) / 2); List&lt;Integer&gt; list2 = list.subList(2, list.size()); return f(list2); &#125;&#125; 思考：首先对绳子的长度进行排序，取最短的两根绳子a、b，对折，对折后的长度一定不会超过这两根绳子的最大长度，所有不需要担心打乱顺序。只需要一次排序就行。 代码v2.0: import java.util.ArrayList;import java.util.Collections;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); int N = in.nextInt(); for (int i = 0; i &lt; N; i++) &#123; list.add(in.nextInt()); &#125; Collections.sort(list); int result=list.get(0); for(int i=1;i&lt;list.size();i++) &#123; result=(result+list.get(i))/2; &#125; System.out.println(result); &#125;&#125;]]></content>
      <categories>
        <category>每日一道编程题</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零基础学高数010：微分中值定理]]></title>
    <url>%2F2019%2F03%2F07%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E9%AB%98%E6%95%B0010%EF%BC%9A%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[1.罗尔定理 !!! 2.拉格朗日中值定理(很重要！！！) 3.柯西中值定理 注：（要明白课本上3个定理的证明过程）]]></content>
      <categories>
        <category>数学</category>
        <category>考研</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
        <tag>考研复习</tag>
        <tag>高昆轮</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[方格计数]]></title>
    <url>%2F2019%2F03%2F06%2F%E6%96%B9%E6%A0%BC%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[第九届蓝桥杯题2： 标题：方格计数 如图所示，在二维平面上有无数个1x1的小方格。 我们以某个小方格的一个顶点为圆心画一个半径为1000的圆。 你能计算出这个圆里有多少个完整的小方格吗？ 注意：需要提交的是一个整数，不要填写任何多余内容。 思路1： 将圆以圆心为原点作横纵坐标轴，分成四个象限，圆中完整小方格的数目=第一象限圆内完整方格数*4； 对第一象限圆内的坐标点进行遍历，圆内某点p1(x,y)，p1左边相邻点p2(x-1,y)，p1上边相邻点p3(x,y+1)， 若p1、p2、p3三点同时在圆内→这三点所确定的小方格在圆内 Java代码： public class Main &#123; public static void main(String[] args) &#123; int count = 0; for (int i = 1; i &lt;= 1000; i++) &#123; for (int j = 0; j &lt;= 1000; j++) &#123; if (f(i, j)) &#123; count++; &#125; &#125; &#125; System.out.println(count * 4);//注意要乘4:4个象限 &#125; private static boolean f(int x, int y) &#123; if (x * x + y * y &lt;= 1000 * 1000 &amp;&amp; (x - 1) * (x - 1) + y * y &lt;= 1000 * 1000 &amp;&amp; x * x + (y + 1) * (y + 1) &lt;= 1000 * 1000) &#123; return true; &#125; return false; &#125;&#125; 输出结果：3137548 思路2： 只看第一象限，a点 从x轴从右往左遍历，b从a点出发，往上走，直到刚要走出圆，这时候 原点与a，a与b，形成一个矩形，count+=矩形面积（即为该矩形包含方格个数），然后a继续走，b继续走，又形成一个矩形，但这次b，就要减去上次b的y坐标； Java代码： public class Main0102 &#123; public static void main(String[] args) &#123; int a,b=0,preB=b,count=0; for(a=1000;a&gt;=0;a--) &#123; while(a*a+b*b&lt;=1000*1000) &#123; b++; &#125; b--; count+=a*(b-preB);//preB为上一次b点的值 preB=b; &#125; System.out.println(count*4); &#125;&#125; 输出结果：3137548]]></content>
      <categories>
        <category>每日一道编程题</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零基础学高数009：导数与微分的计算]]></title>
    <url>%2F2019%2F03%2F04%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E9%AB%98%E6%95%B0009%EF%BC%9A%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86%E7%9A%84%E8%AE%A1%E7%AE%97%2F</url>
    <content type="text"><![CDATA[1.基本求导公式： 2.四则运算法则： 复合函数的求导法则 3.反函数的求导法则：反函数定义： 反函数求导法则: 画图证明： 4.幂指函数求导法则： 5.隐函数求导法则： 6.参数方程求导法则： 7.高阶导数求导法则： [注]：前两条与求一阶导公式一致，但第三条与求一阶导有所不同。 常见的几个函数的n阶导： 例题：]]></content>
      <categories>
        <category>数学</category>
        <category>考研</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
        <tag>考研复习</tag>
        <tag>高昆轮</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阶乘计算]]></title>
    <url>%2F2019%2F03%2F02%2F%E9%98%B6%E4%B9%98%E8%AE%A1%E7%AE%97%2F</url>
    <content type="text"><![CDATA[问题描述 输入一个正整数n，输出n!的值。 其中n!=123…**n。 算法描述 n!可能很大，而计算机能表示的整数范围有限，需要使用高精度计算的方法。使用一个数组A来表示一个大整数a，A[0]表示a的个位，A[1]表示a的十位，依次类推。 将a乘以一个整数k变为将数组A的每一个元素都乘以k，请注意处理相应的进位。 首先将a设为1，然后乘2，乘3，当乘到n时，即得到了n!的值。 输入格式 输入包含一个正整数n，n&lt;=1000。 输出格式 输出n!的准确值。 样例输入 10 样例输出 3628800 由于n的值可能很大，所以一般不能简单地运用暴力枚举的方法进行解题。但若采用Java进行解题，则Java中的BigInteger类型则可以承受住n的取值过大的问题，代码如下： import java.math.BigInteger;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in=new Scanner(System.in); int n=in.nextInt(); BigInteger result=BigInteger.ONE; for(int i=n;i&gt;0;i--) &#123; result=result.multiply(BigInteger.valueOf(i)); &#125; System.out.println(result); &#125;&#125; 运行结果： 103628800 但其他常见语言如C、C++并不具备类似于Java中BigInteger这样的数据类型，因此有如下解法。 采用递归解题： import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in=new Scanner(System.in); int n=in.nextInt(); System.out.println(f(n)); &#125; private static int f(int n) &#123; if(n==1) &#123;return 1;&#125; return n*f(n-1); &#125;&#125; 运行结果： 103628800 但当n继续增大到一定程度时，递归算法仍无法算出结果。 利用数组： import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in=new Scanner(System.in); int n=in.nextInt(); int [] result=new int[1000*100]; result[0]=1; int num,r; for(int i=2;i&lt;=n;i++) &#123; r=0; for(int j=0;j&lt;result.length;j++) &#123; num=result[j]*i+r;//当前阶乘所得到的结果num result[j]=num%10;//当前result[j]中该存放的应是临时结果num的低位对应数值 r=num/10;//当前临时结果num的高位对应数值 &#125; &#125; int index=0; for(int i=result.length-1;i&gt;=0;i--) &#123; if(result[i]!=0) &#123;//反向遍历数组找到首次≠0的元素，即为最终阶乘结果的最高位数值 index=i;//记录下阶乘结果最高位数值的下标index break; &#125; &#125; for(int i=index;i&gt;=0;i--) &#123;//反向遍历result[index]~result[0]即为最后结果 System.out.print(result[i]); &#125; &#125;&#125; 理解难点： for(int j=0;j&lt;result.length;j++) {​ num=result[j]*i+r;//当前阶乘所得到的结果num​ result[j]=num%10;//当前result[j]中该存放的应是临时结果num的低位对应数值​ r=num/10;//当前临时结果num的高位对应数值​ } 重点理解：num=result[j]*i+r; 【注】：将阶乘过程中的每次乘的结果的个位、十位、百位…反向存在数组中，考虑进位！进位！进位！当某一次乘的数为n时，则代表乘到了最后。 拓展训练： 代码： import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); String sa = sc.next(); String sb = sc.next(); int[] a = new int[100]; int[] b = new int[100]; int[] c = new int[101]; int count = 0; for (int i = sa.length() - 1; i &gt;= 0; i--) &#123; a[count++] = Integer.parseInt(sa.substring(i, i + 1)); &#125; count = 0; for (int i = sb.length() - 1; i &gt;= 0; i--) &#123; b[count++] = Integer.parseInt(sb.substring(i, i + 1)); &#125; int r = 0, x=0,y=0; for(int i=0;i&lt;c.length;i++) &#123; if(x&gt;=100||y&gt;=100) &#123; break; &#125; int result = (a[x++] + b[y++])+r; c[i] = result % 10; r = result / 10; &#125; int flag=0; for(int i=c.length-1;i&gt;=0;i--) &#123; if(c[i]!=0) &#123; flag=i; break; &#125; &#125; for (int i = flag; i &gt;= 0; i--) &#123; System.out.print(c[i]); &#125; &#125;&#125;]]></content>
      <categories>
        <category>每日一道编程题</category>
      </categories>
      <tags>
        <tag>阶乘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零基础学高数008：导数与微分的定义]]></title>
    <url>%2F2019%2F03%2F02%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E9%AB%98%E6%95%B0008%EF%BC%9A%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86%E7%9A%84%E5%AE%9A%E4%B9%89%2F</url>
    <content type="text"><![CDATA[1.导数的定义 2.导数的几何意义 3.微分的定义 4.微分的几何意义 5.连续、可导、可微的关系 例题例题1： 拓展训练: 例题2： 例题3： 例题4： 例题5： 由例题5可得出以下结论：]]></content>
      <categories>
        <category>数学</category>
        <category>考研</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
        <tag>考研复习</tag>
        <tag>高昆轮</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零基础学高数007：极限的应用03]]></title>
    <url>%2F2019%2F02%2F28%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E9%AB%98%E6%95%B0007%EF%BC%9A%E6%9E%81%E9%99%90%E7%9A%84%E5%BA%94%E7%94%A803%2F</url>
    <content type="text"><![CDATA[1.有界性与最大值最小值定理 2.介值定理 3.零点定理 例题：]]></content>
      <categories>
        <category>数学</category>
        <category>考研</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
        <tag>考研复习</tag>
        <tag>高昆轮</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不定方程求解]]></title>
    <url>%2F2019%2F02%2F28%2F%E4%B8%8D%E5%AE%9A%E6%96%B9%E7%A8%8B%E6%B1%82%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[【题目描述】给定正整数a，b，c。求不定方程 ax+by=c 关于未知数x和y的所有非负整数解组数。 【输入】一行，包含三个正整数a，b，c，两个整数之间用单个空格隔开。每个数均不大于1000。 【输出】一个整数，即不定方程的非负整数解组数。 【输入样例】 2 3 18【输出样例】 4 一般解法： 暴力循环： import java.util.Scanner;public class Main &#123; static int count=0; public static void main(String[] args) &#123; Scanner in=new Scanner(System.in); int a=in.nextInt(); int b=in.nextInt(); int c=in.nextInt(); f(a,b,c); System.out.println(count); &#125; private static void f(int a, int b, int c) &#123; for(int i=0;i&lt;100;i++) &#123; for(int j=0;j&lt;100;j++) &#123; if(a*i+b*j==c) &#123; count++; &#125; &#125; &#125; &#125;&#125; 运行结果： 2 3 18a=2 b=3 c=180*a+6*b=183*a+4*b=186*a+2*b=189*a+0*b=18不定方程的非负整数解组数：4 上述解法虽然得出了正确解，但是若a、b、c的值取得很大，则此方法失效。 改进解法1： import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in=new Scanner(System.in); int a=in.nextInt(); int b=in.nextInt(); int c=in.nextInt(); System.out.println("a="+a+" b="+b+" c="+c); System.out.println("不定方程的非负整数解组数："+f(a,b,c)); &#125; private static int f(int a, int b, int c) &#123; int count=0; for(int i=0;i&lt;=c/a;i++) &#123; for(int j=0;j&lt;=c/b;j++) &#123; if(a*i+b*j==c) &#123; System.out.println(i+"*a"+"+"+j+"*b="+c); count++; &#125; &#125; &#125; return count; &#125;&#125; 运行结果： 2 3 18a=2 b=3 c=180*a+6*b=183*a+4*b=186*a+2*b=189*a+0*b=18不定方程的非负整数解组数：4 此解法相对于暴力遍历的关键处在于减少了遍历的次数：for(int i=0;i&lt;=c/a;i++) ，for(int j=0;j&lt;=c/b;j++) 【注】：千万不能写成：for(int i=0;i&lt;c/a;i++) ，for(int j=0;j&lt;c/b;j++) 。否则会忽略x与y等于0的情况 改进解法2： import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int a = in.nextInt(); int b = in.nextInt(); int c = in.nextInt(); System.out.println("a="+a+" b="+b+" c="+c); System.out.println("不定方程的非负整数解组数：" + f(a, b, c)); &#125; private static int f(int a, int b, int c) &#123; int count = 0; int x0 = 0, y0 = 0; //1.先求出一组特殊姐 for (x0 = 0; x0 &lt;= c / a; x0++) &#123; y0 = (c - a * x0) / b; if (a * x0 + b * y0 == c) &#123; break; &#125; &#125; //2.求通解， x = x0 +bt; y = y0 - at int x, y; for(int t = -100; t &lt; 100; t++)&#123; x = x0 + b * t; y = y0 - a * t; if (a * x + b * y == c&amp;&amp; x&gt;=0 &amp;&amp; y&gt;=0) &#123; System.out.println(x+"*a"+"+"+y+"*b="+c); count++; &#125; &#125; return count; &#125;&#125; 运行结果： 2 3 18a=2 b=3 c=180*a+6*b=183*a+4*b=186*a+2*b=189*a+0*b=18不定方程的非负整数解组数：4]]></content>
      <categories>
        <category>每日一道编程题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>蓝桥杯</tag>
        <tag>不定方程求解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵中的路径]]></title>
    <url>%2F2019%2F02%2F27%2F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[问题描述请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 时间限制：1秒 空间限制：32768K public class Solution { public static boolean hasPath(char[] matrix, int rows, int cols, char[] str) {​​ } } 解题思路题中所给代码hasPath方法参数含义： char[] matrix：用一位数组表示矩阵 int rows, int cols：矩形的行列数 char[] str：需要在矩形中找寻路径的字符串，待判定的字符串 寻找路径：实际上是判断每次走到的格子是否满足题目要求，第一次走： 这个格子中的字符==str的第一个字符 这个格子没有被走过 这个格子的横坐标、纵坐标未超出范围 当满足以上三点条件之后，表示该格子可以走，然后再对该格子的上下左右四个格子进行以上三点判断，重复1、2、3； 若上下左右四个格子中的某一个格子符合1、2、3三点要求，则重复4； 当待判定的字符串已经判断到了最后一个字符，说明成功找到路径。 我的代码public class Solution &#123; public static boolean hasPath(char[] matrix, int rows, int cols, char[] str) &#123; //创建一个与matrix同长度的标志数组，默认赋值false,若该格子已经被走过，则赋值true boolean[] flag = new boolean[matrix.length]; //遍历矩阵中的每一个格子 for (int x = 0; x &lt; rows; x++) &#123; for (int y = 0; y &lt; cols; y++) &#123;//find()：循环遍历矩阵格子，找到起点等于str第一个元素的值，再递归判断四周是否有符合条件的----回溯法 if(find(matrix, x, y, flag, str, 0, rows, cols)) &#123; return true; &#125; &#125; &#125; return false; &#125;//x、y：当前格子的横纵坐标 k:str中正在进行匹配的第k+1个字符（str[k]) private static boolean find(char[] matrix, int x, int y, boolean[] flag, char[] str, int k, int rows, int cols) &#123; if(k==str.length-1) &#123;//当待判定的字符串已经判断到了最后一个字符，说明成功找到路径 return true; &#125; int index=x*cols+y;//通过当前格子的横纵坐标求出该格子在matrix中对应下标 /* 若 横纵坐标超出合理范围 或者 当前格子≠str[k] 或者 当前格子被走过 都表示当前格子不可用， 返回false，返回至hasPath方法继续寻找矩阵中第二个起点等于str第一个元素的值 */ if(x&lt;0||y&lt;0||x&gt;=rows||y&gt;=cols||str[k]!=matrix[index]||flag[index]) &#123; return false; &#125; flag[index]=true;//当前格子可走,将标志数组对应元素赋值为true，表示以及走过 //对 当前格子的上下左右四个格子的字符进行判断，寻找与str[k+1]相匹配的第二个格子 if(find(matrix, x-1, y, flag, str, k+1, rows, cols)|| find(matrix, x+1, y, flag, str, k+1, rows, cols)|| find(matrix, x, y-1, flag, str, k+1, rows, cols)|| find(matrix, x, y+1, flag, str, k+1, rows, cols)) &#123; return true; &#125; flag[index]=false;//此路不通，将上面的true还原（回溯） return false;//返回false至hasPath方法，寻找其他路径 &#125;&#125;]]></content>
      <categories>
        <category>每日一道编程题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零基础学高数006：极限的应用02]]></title>
    <url>%2F2019%2F02%2F27%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E9%AB%98%E6%95%B0006%EF%BC%9A%E6%9E%81%E9%99%90%E7%9A%84%E5%BA%94%E7%94%A802%2F</url>
    <content type="text"><![CDATA[1.连续的定义 2.间断点的定义与分类定义： 间断点的分类： 左右极限都存在的间断点是第一类间断点，其中左右极限相等的间断点称为可去间断点，左右极限不等的间断点称为跳跃间断点。 左右极限至少有一个不存在的间断点称为第二类间断点。 3.连续函数的运算性质 两个连续函数的和、差、积、商(分母≠0)所得的函数仍是连续函数。 连续函数复合连续函数所得的函数仍是连续函数。(只有连续复合连续才仍是连续，其他情况不一定是连续，也不一定不是连续) 基本初等函数在其定义域内连续。 初等函数在其定义区间内连续。]]></content>
      <categories>
        <category>数学</category>
        <category>考研</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
        <tag>考研复习</tag>
        <tag>高昆轮</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大公约数与最小公倍数：辗转相除法]]></title>
    <url>%2F2019%2F02%2F27%2F%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E4%B8%8E%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0%EF%BC%9A%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95%2F</url>
    <content type="text"><![CDATA[已知两个数x和y，求x和y的最大公约数 暴力循环求解： public static void gcd(int x, int y) &#123; if (y &gt; x) &#123;//如果y&gt;x，交换x与y int t = x; x = y; y = t; &#125; for (int i = y; i &gt; 0; i--) &#123; if (x % i == 0 &amp;&amp; y % i == 0) &#123; System.out.println(i); break; &#125; &#125;&#125; 辗转相除法求解： public static void gcd(int x, int y) &#123; while(true) &#123; if(y==0) &#123; System.out.println(x); break; &#125; int t=y; y=x%y; x=t; &#125; &#125; 辗转相除法递归求解： public static void gcd(int x, int y) &#123; if (y == 0) &#123; System.out.println(x); return; &#125; gcd(y, x % y);&#125; 理解辗转相除法： 最小公倍数： 【定理】：两个数的乘积等于这两个数的最大公约数与最小公倍数的积，即（a，b）×[a，b]=a×b，a，b的最大公约数记为（a，b），a，b的最小公倍数记为[a，b]。 所以[a，b]=a×b / (a，b) 两个数的最小公倍数求解： import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int x = in.nextInt(); int y = in.nextInt(); System.out.println(lcm(x, y)); &#125; public static int lcm(int x, int y) &#123;//求两个数的最小公倍数 return (x*y)/gcd(x,y); &#125; public static int gcd(int x, int y) &#123; if (y == 0) &#123; return x; &#125; return gcd(y, x % y); &#125;&#125; 求多个数的最大公约数和最小公倍数： public class Main &#123; public static void main(String[] args) &#123; int[] nums = &#123; 27, 18, 9, 81 &#125;; System.out.println("最大公约数：" + gcdMore(nums, 3)); System.out.println("最小公倍数：" + lcmMore(nums, 3)); &#125; public static int gcd(int x, int y) &#123; if (y == 0) &#123; return x; &#125; return gcd(y, x % y); &#125; public static int lcm(int x, int y) &#123;// 求两个数的最小公倍数 return (x * y) / gcd(x, y); &#125; private static int gcdMore(int[] nums, int n) &#123;// 求多个数的最大公约数 if (n == 1) return nums[n - 1]; return gcd(nums[n - 1], gcdMore(nums, n - 1)); &#125; private static int lcmMore(int[] nums, int n) &#123;// 求多个数的最小公倍数 if (n == 1) return nums[n - 1]; return lcm(nums[n - 1], lcmMore(nums, n - 1)); &#125;&#125; 讲解： 求n个数的最大公约数:采用递归。与求两个数的最大公约数一样，先将前面n-1个数的最大公约数求出来，再与第n个数进行辗转相除； 求n个数的最小公倍数:采用递归。与求两个数的最小公倍数一样，先将前面n-1个数的最小公倍数a求出来，再求该a与第n个数的最小公倍数； 参考1 参考2]]></content>
      <categories>
        <category>每日一道编程题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>辗转相除法</tag>
        <tag>最大公约数</tag>
        <tag>最小公倍数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零基础学高数005：极限的应用01]]></title>
    <url>%2F2019%2F02%2F26%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E9%AB%98%E6%95%B0005%EF%BC%9A%E6%9E%81%E9%99%90%E7%9A%84%E5%BA%94%E7%94%A801%2F</url>
    <content type="text"><![CDATA[1.无穷小的定义 2.无穷小的比较 3.无穷小的性质 4.无穷小的运算规则 5.无穷大的定义 6.几个常用的无穷大 7.无穷大与无界的关系无穷大是无界，无界未必是无穷大. 8.无穷大与无穷小的关系]]></content>
      <categories>
        <category>数学</category>
        <category>考研</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
        <tag>考研复习</tag>
        <tag>高昆轮</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2n皇后问题]]></title>
    <url>%2F2019%2F02%2F26%2F2n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[思路： 实现解题的三步走： 1)第一步，从第一行的第一个进行放置皇后（先放黑或白都可以），然后首先要进行的是对当前位置能否放置皇后的判断，若是1，则可以放；否则不能放。如果不能放，则进行第一行的第二个的位置判断。如果是1，则进行第二步。 2)第二步，是在满足当前位置的值为1的情况下，进行“同一行、同一列或同一条对角线上，任意的两个白（黑）皇后都不在同一行、同一列或同一条对角线上”的判断，而判断的顺序为当前位置的上面，左对角线，右对角线是否有已经放过的白（黑）皇后，若有，则返回值为false，即该点不能进行白（黑）皇后的放置。则进行了同一行的下一位置的判断，依然是第一步和第二步的判断。若没有，则返回true，即该点可以放置，进行第三步操作。 3)第三步，在经过前两步的判断过后，则需要对通过判断的位置进行皇后的放置，白皇后用2表示，黑皇后用3表示，即对通过前两步判断的位置进行2或3的赋值。然后进行下一行第一个位置的放置。然后是回溯法的重点，当完成所有的放置，或满足不了放置的条件则需要将放置了皇后的点的值改变为原来的1。如果四个白皇后都放置完了，则进行黑皇后的放置，而黑皇后也满足了皇后个数的放置则表示找到了一种方法，计数变量进行加一操作。若过程中没有满足皇后的个数，进行上一步的回溯，下一位置继续进行判断，以此类推。 import java.util.Scanner;public class Main &#123; static int n;//待输入的整数n，表示期盼的大小 static int sum;//记录摆法的个数，即最终返回的结果 static int[][] arr;//二维数组表示棋盘 public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); n = in.nextInt(); arr = new int[n][n]; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; arr[i][j] = in.nextInt(); &#125; &#125; DFS(0, 2);//从第一行开始，对白皇后进行放置，0表示第一行的下标，2表示白皇后 System.out.println(sum); &#125; private static void DFS(int x, int num) &#123; if (x== n) &#123; //达到最后一行，当前颜色皇后放置完毕 if(num==2)DFS(0,3); //如果当前摆放完毕的是白皇后，则进行黑皇后的放置 else sum++;//否则表示摆放完毕的是黑皇后，放置方法找到了一种，计数变量进行值加一 return ; &#125; for (int y = 0; y &lt; n; y++) &#123;//对当前行的各个位置进行判断能否摆放,y表示纵坐标 if(arr[x][y]!=1) &#123;//若当前位置不为1，表示不能摆放 continue;//对当前位置的下一坐标点进行判断,即x不变，y+1 &#125; if (Check(x,y,num)) &#123; /*Check：判断当前位置进行同行、同列、同对角线上是否已经放置了当前颜色的皇后， *若存在已放置皇后，则当前位置不能放置皇后，返回false，否则返回true */ arr[x][y]=num;//返回true，当前位置可放,将当前坐标值赋为2（2:白皇后;3:黑皇后） &#125;else &#123; continue;//返回false，当前位置不可放，对当前行的下一位置进行判断 &#125; DFS(x+1,num); // 开始摆放下一行(x+1)的皇后，同样从第0列开始摆放 arr[x][y]=1 ;// 每次摆放完一种皇后后，都要将其撤回，再试探其它的摆法。“回溯” &#125; &#125; public static boolean Check(int x,int y,int num)//满足题目要求的判断函数 &#123; for(int preX=x-1;preX&gt;=0;preX--) &#123; //当前位置上方是否进行了相同皇后的放置 这行以下的还没放不检查 （同行检查） if(arr[preX][y]==num) return false; &#125; for(int preX=x-1,perY=y-1;preX&gt;=0&amp;&amp;perY&gt;=0;preX--,perY--) &#123; //检查左对角线 这行以下的还没放不检查 （左对角线检查） if(arr[preX][perY]==num) return false; &#125; for(int preX=x-1,perY=y+1;preX&gt;=0&amp;&amp;perY&lt;=n-1;preX--,perY++) &#123; //检查右对角线 这行以下的还没放不检查 （右对角线检查） if(arr[preX][perY]==num) return false; &#125; return true;//都满足的情况下，则可以进行当前皇后的放置 &#125; &#125; 注:代码段中的Check();方法没有对同一行之前的位置进行判断，是因为同一行是从左到右依次放置的，若前面放了则直接是下一行的判断，不会是相邻右侧的位置进行放置，则不需要进行判断，同理右侧，下方都不用，因为还没有进行皇后的放置，本题是回溯法经典的应用，递归的思想。若想深刻的领悟，应该跟着程序一步步的进行解读，进行逐渐的理解，掌握递归的思想，回溯的精髓。]]></content>
      <categories>
        <category>每日一道编程题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零基础学高数004：极限的计算]]></title>
    <url>%2F2019%2F02%2F23%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E9%AB%98%E6%95%B0004%EF%BC%9A%E6%9E%81%E9%99%90%E7%9A%84%E8%AE%A1%E7%AE%97%2F</url>
    <content type="text"><![CDATA[求极限的方法（仅限当前所学内容，后续还会有零零散散的方法） 方法一：利用四则运算与基本极限求极限 常见的基本极限有： [例]： 方法二：利用等价代换求极限 方法三：利用夹逼准则求极限 方法四：利用单调有界准则求极限 单调增且有上界，则极限存在； 单调减且有下界，则极限存在。]]></content>
      <categories>
        <category>数学</category>
        <category>考研</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
        <tag>考研复习</tag>
        <tag>高昆轮</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归：总金额出错账单明细]]></title>
    <url>%2F2019%2F02%2F23%2F%E9%80%92%E5%BD%92%EF%BC%9A%E6%80%BB%E9%87%91%E9%A2%9D%E5%87%BA%E9%94%99%E8%B4%A6%E5%8D%95%E6%98%8E%E7%BB%86%2F</url>
    <content type="text"><![CDATA[【问】：某财务部门结账时发现总金额不对头。很可能是从明细上漏掉了某1笔或几笔。如果已知明细账目清单，能通过编程找到漏掉的是哪1笔或几笔吗？ 如果有多种可能，则输出所有可能的情况。 我们规定：用户输入的第一行是：有错的总金额。 接下来是一个整数n，表示下面将要输入的明细账目的条数。 再接下来是n行整数，分别表示每笔账目的金额。 要求程序输出：所有可能漏掉的金额组合。每个情况1行。金额按照从小到大排列，中间用空格分开。 比如： 用户输入： 6 5 3 2 4 3 1 表明：有错的总金额是6；明细共有5笔。此时，程序应该输出： 1 3 3 1 2 4 3 4 为了方便，不妨假设所有的金额都是整数；每笔金额不超过1000，金额的明细条数不超过100。 我的代码： import java.util.Arrays;import java.util.HashSet;import java.util.Scanner;public class Main &#123; static HashSet&lt;String&gt; set=new HashSet&lt;String&gt;();//存储所有可能漏掉的金额组合 public static void main(String[] args)&#123; Scanner in=new Scanner(System.in); int err_sum=in.nextInt();//有错的总金额 int N=in.nextInt();//下面将要输入的明细账目的条数 int[] a=new int[N];//存储每笔账单金额 int k=0; for (int i = 0; i &lt;N ; i++) &#123; a[i]=in.nextInt(); &#125; Arrays.sort(a);//为了满足金额按照从小到大排列 boolean[] b=new boolean[N]; f(err_sum,a,k,b,0); for (String str : set) &#123; System.out.println(str); &#125; &#125; private static void f(int err_sum, int[] a, int k, boolean[] b, int curr_sum) &#123; String s=""; if (curr_sum&gt;err_sum) &#123; return; &#125; if (err_sum==curr_sum) &#123; for (int i = 0; i &lt; b.length; i++) &#123; if (b[i]==false) &#123; s+=a[i]+" "; &#125; &#125; set.add(s); return ; &#125; if (k==a.length) &#123;//当 当前元素等于最后一个元素时，遍历完毕 return; &#125; b[k]=false;//没有这一步也行，因为数组b默认初始为false f(err_sum, a, k+1, b, curr_sum); curr_sum+=a[k];//是否加上当前项，现一加上，置为true b[k]=true; f(err_sum, a, k+1, b, curr_sum); b[k]=false;//回溯，以便后一次遍历恢复原来数据 &#125;&#125; 讲解： b[k]=false; f(err_sum, a, k+1, b, curr_sum); curr_sum+=a[k]; b[k]=true; f(err_sum, a, k+1, b, curr_sum); b[k]=false; 每遍历到数组a中某一元素a[k]，都有取与不取两种情况： 不取：将此元素标记为false,即b[k]=false，然后继续遍历下一元素a[k+1] 取：curr_sum加上a[k]，并将此元素标记为true， 即b[k]=true，然后继续遍历下一元素。]]></content>
      <categories>
        <category>每日一道编程题</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[青蛙变态跳台阶]]></title>
    <url>%2F2019%2F02%2F23%2F%E9%9D%92%E8%9B%99%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6%2F</url>
    <content type="text"><![CDATA[【请先食用上一篇】：青蛙跳台阶 问:一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 解题思路: 一共有n级台阶，第一次跳青蛙可以跳1，2，3……n级台阶 假设：f(n)表示：n个台阶第一次1,2,…n阶的跳法数;若第一次跳了1阶，则还剩n-1阶，假设：f(n-1)表示：n-1个台阶第一次1,2,…n-1阶的跳法数;若第一次跳了2阶，则还剩n-2阶，假设：f(n-2)表示：n-1个台阶第一次1,2,…n-2阶的跳法数;把所以可能的情况（第一次可能跳1,2,…,n阶）加起来：可以求出：f(n) = f(n-1) + f(n-2) + … + f(1)递归：f(n-1) = f(n-2) + … + f(1)可以求出：f(n) = 2*f(n-1) 看图理解： 我的代码： public class Solution &#123; public int JumpFloorII(int target) &#123; if(target==1)&#123;//当台阶数为1时，只有一种跳法 return 1; &#125; if(target==0)&#123; return 0; &#125; return 2*JumpFloorII(target-1); &#125;&#125; 更实用的解法是：从下往上计算，避免了递归的多余计算量 public class Solution &#123; public int JumpFloorII(int target) &#123; int a = 1, b = 0; if (target &lt;= 0) &#123; return 0; &#125; else if (target == 1) &#123; return 1; &#125; else &#123; for (int i = 2; i &lt;= target; i++) &#123; b = 2 * a; a = b; &#125; return b; &#125; &#125;]]></content>
      <categories>
        <category>每日一道编程题</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>迭代</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典递归问题：求两个字符串的最长公共子序列的长度]]></title>
    <url>%2F2019%2F02%2F17%2F%E7%BB%8F%E5%85%B8%E9%80%92%E5%BD%92%E9%97%AE%E9%A2%98%EF%BC%9A%E6%B1%82%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[公共子序列与公共子串的区别 公共子序列是在整个字符串中只要按照顺序可以不用连续的，但是公共子串是指必须连续的字符串，举个例子: ABCBDABBDCABA 最长公共子序列是 : BCBA 最长公共字串是 : AB 递归【思路】： 先将两个字符串的第一个字符进行比较： 两串的第一个字符相同：再将两字符串剩余子串进行继续比较 两串的第一个字符不同：①.将串1的剩余子串与串2整串进行比较；②.将串2的剩余子串与串1整串进行比较→①和②中的较大者即为最大公共子序列长度 public class Main &#123; public static void main(String[] args)&#123; int len=f("viced","viecddh"); System.out.println(len); &#125; private static int f(String s1, String s2) &#123; if(s1.length()==0||s2.length()==0)&#123;//当某一字符串长度为0时表示其中一个字符串比较完毕 return 0; &#125; if(s1.charAt(0)==s2.charAt(0))&#123;//第一个字符相同 return f(s1.substring(1),s2.substring(1))+1; &#125;else&#123;//第一个字符不同 return Math.max(f(s1.substring(1),s2),f(s1,s2.substring(1))); &#125; &#125; 动态规划当所比较的两个字符串非常长时，采用递归重复的子问题多，效率低下，求解很容易发生栈溢出，改进的办法——用空间换时间，用数组保存中间状态，方便后面的计算。这就是动态规划（DP)的核心思想了。 public class Main &#123; public static void main(String[] args)&#123; int len=f("viceddgbgfhb","viecddhjnghjghjgjgh"); System.out.println(len); &#125; private static int f(String str1, String str2) &#123; int len1 = str1.length(); int len2 = str2.length(); int c[][] = new int[len1+1][len2+1]; for (int i = 0; i &lt;= len1; i++) &#123; for( int j = 0; j &lt;= len2; j++) &#123; if(i == 0 || j == 0) &#123; c[i][j] = 0; &#125; else if (str1.charAt(i-1) == str2.charAt(j-1)) &#123; c[i][j] = c[i-1][j-1] + 1; &#125; else &#123; c[i][j] = Math.max(c[i - 1][j], c[i][j - 1]); &#125; &#125; &#125; return c[len1][len2]; &#125;&#125; 参考：https://blog.csdn.net/qq_31881469/article/details/77892324]]></content>
      <categories>
        <category>每日一道编程题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>蓝桥杯</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典递归问题：全排列问题]]></title>
    <url>%2F2019%2F02%2F15%2F%E7%BB%8F%E5%85%B8%E9%80%92%E5%BD%92%E9%97%AE%E9%A2%98%EF%BC%9A%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[【题目】设计一个递归算法生成n个元素{r1,r2,…,rn}的全排列。 【算法讲解】： 设R={r1,r2,…,rn}是要进行排列的n个元素，Ri=R-{ri}。集合X中元素的全排列记为perm(X)。(ri)perm(X)表示在全排列perm(X)的每一个排列前加上前缀得到的排列。R的全排列可归纳定义如下：当n=1时，perm(R)=(r)，其中r是集合R中唯一的元素；当n&gt;1时，perm(R)由(r1)perm(R1)，(r2)perm(R2)，…，(rn)perm(Rn)构成。 实现思想：将整组数中的所有的数分别与第一个数交换，这样就总是在处理后n-1个数的全排列。 【示例】 当n=3，并且E={a，b，c}，则：perm(E)=a.perm({b,c}) + b.perm({a,c}) + c.perm({a,b})perm({b,c})=b.perm(c) + c.perm(b)a.perm({b,c})=a.b.perm(c) + a.c.perm(b)​ =a.b.c + a.c.b=(abc, acb) 我的代码： public class Main &#123; public static void main(String[] args)&#123; char[] data="ABC".toCharArray(); f(data,0); &#125; private static void f(char[] data,int k) &#123; if(k==data.length)&#123;//只剩下一个元素 for(int i=0;i&lt;data.length;i++)&#123; System.out.print(data[i]+" "); &#125; System.out.println(); &#125; for(int i=k;i&lt;data.length;i++)&#123; &#123;char c=data[k];data[k]=data[i];data[i]=c;&#125;//试探 f(data,k+1); &#123;char c=data[k];data[k]=data[i];data[i]=c;&#125;//回溯 &#125; &#125;&#125; 关于回溯： 3个电灯串联在一起，其中有个灯泡坏了，通过在灯泡正负极接上一根导线的方法来筛选出坏了的灯泡，每次检测下一灯泡时，必须先将连在上一灯泡的导线取下，保持在最初状态，这就是回溯。]]></content>
      <categories>
        <category>每日一道编程题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>蓝桥杯</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零基础学高数003：极限的定义与性质]]></title>
    <url>%2F2019%2F02%2F13%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E9%AB%98%E6%95%B0003%EF%BC%9A%E6%9E%81%E9%99%90%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%80%A7%E8%B4%A8%2F</url>
    <content type="text"><![CDATA[极限的定义 自变量 x 的描述 因变量f(x)的描述 [定义]： 注释: 举例说明: 其他注释： [定理]： 思考：既然极限分为左侧和右侧，极限存在的要求是存在左极限与右极限且二者相等,那么计算时是否需要分别针对左极限和右极限进行求解呢？ 答案为看情况，以下是需要考察左右极限的3种情形： 需要考察左右极限的3种情形: 例题: 极限的性质]]></content>
      <categories>
        <category>数学</category>
        <category>考研</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
        <tag>考研复习</tag>
        <tag>高昆轮</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[青蛙跳台阶]]></title>
    <url>%2F2019%2F02%2F13%2F%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%2F</url>
    <content type="text"><![CDATA[题目描述： 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 思路： 我们先考虑青蛙第一跳： 第一次跳1个台阶，那么还剩n-1个台阶，跳法为f(n-1) 第一次跳2个台阶，那么还剩n-2个台阶，跳法为f(n-2) 所以总的跳法:f(n)=f(n-1)+f(n-2) 当跳到只剩1个台阶时，有1种跳法：f(1)=1 当跳到只剩2个台阶时，有2种跳法：f(2)=2 观察发现，这就是一个斐波那契数列 我的代码： public int JumpFloor(int target) &#123;//target为台阶总数 if(target==2)&#123; return 2; &#125; if(target==1)&#123; return 1; &#125; if(target&lt;=0)&#123; return 0; &#125; return JumpFloor(target-1)+JumpFloor(target-2); &#125; 运行时间：544ms 占用内存：9056 k 改进： 为避免递归产生的栈溢出，改用自底向上的动态规划（迭代）来解题： public int JumpFloor(int target) &#123; if(target==2)&#123; return 2; &#125; if(target==1)&#123; return 1; &#125; if(target&lt;=0)&#123; return 0; &#125; int first = 1, second = 2, third = 0; for (int i = 3; i &lt;= target; i++) &#123; third = first + second; first = second; second = third; &#125; return third; &#125; 运行时间：15ms 占用内存：9328 k]]></content>
      <categories>
        <category>每日一道编程题</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>迭代</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划：斐波那契数列]]></title>
    <url>%2F2019%2F02%2F09%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%9A%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[问： 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39 斐波那契数列简单介绍 我的解法： public static int Fibonacci(int n) &#123; if(n &lt;= 1)&#123; return n; &#125; return Fibonacci(n-1)+Fibonacci(n-2); &#125; 注：从Fibonacci(n-1)+Fibonacci(n-2)明显看出使用的是递归，此题用递归两三行代码即可搞定。但是，若出题者准备着一个超大的n，那么很有可能会 Stack Overflow（递归的本质就是栈），为什么会栈溢出？因为重复计算，举个栗子： 当n=4时， Fibonacci(4) = Fibonacci(3) + Fibonacci(2) ​ = Fibonacci(2) + Fibonacci(1) + Fibonacci(1) + Fibonacci(0) ​ = Fibonacci(1) + Fibonacci(0) + Fibonacci(1) + Fibonacci(1) + Fibonacci(0); 由于我们的代码并没有记录Fibonacci(1)和Fibonacci(0)的结果，对于程序来说它每次递归都是未知的，因此光是n=4时Fibonacci(1)就重复计算了3次之多。 其他解法： public int Fibonacci(int n) &#123; int preNum=1; int prePreNum=0; int result=0; if(n&lt;=1) return n; for(int i=2;i&lt;=n;i++)&#123; result=preNum+prePreNum; prePreNum=preNum; preNum=result; &#125; return result; &#125; 注：动态规划（Dynamic Programming）。 动态规划简单介绍：https://blog.csdn.net/u013309870/article/details/75193592 动态规划算法也可以说是 ‘记住求过的解来节省时间’; 动态规划算法的核心就是记住已经解决过的子问题的解。 上述代码需要用到三个数进行操作（preNum、prePreNum、result），实际上可以简化为两个数，从而节省空间，代码如下： public static int Fibonacci(int n) &#123; int pre = 0, next = 1; while(n--&gt;0) &#123; next += pre; pre = next - pre; &#125; return pre; &#125;]]></content>
      <categories>
        <category>每日一道编程题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>蓝桥杯</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零基础学高数002：复合函数+反函数+基本初等函数+初等函数]]></title>
    <url>%2F2019%2F02%2F07%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E9%AB%98%E6%95%B0002%EF%BC%9A%E5%A4%8D%E5%90%88%E5%87%BD%E6%95%B0%E5%92%8C%E5%8F%8D%E5%87%BD%E6%95%B0%2B%E5%9F%BA%E6%9C%AC%E5%88%9D%E7%AD%89%E5%87%BD%E6%95%B0%E5%92%8C%E5%88%9D%E7%AD%89%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[复合函数 反函数 基本初等函数初等函数由常数和基本初等函数经过有限次数的四则运算与有限次数的负荷运算，并能用一个式子表示的函数，称为初等函数.]]></content>
      <categories>
        <category>数学</category>
        <category>考研</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
        <tag>考研复习</tag>
        <tag>高昆轮</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式:懒汉式和饿汉式区别]]></title>
    <url>%2F2019%2F02%2F02%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%87%92%E6%B1%89%E5%BC%8F%E5%92%8C%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[作者：AH_HH来源：CSDN原文：https://blog.csdn.net/qq_35098526/article/details/79893628 单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 【注意】： 单例类只能有一个实例。 单例类必须自己创建自己的唯一实例。 单例类必须给所有其他对象提供这一实例。 明确定义后，看一下代码： 饿汉式 public class SingletonEH &#123; /** *是否 Lazy 初始化：否 *是否多线程安全：是 *实现难度：易 *描述：这种方式比较常用，但容易产生垃圾对象。 *优点：没有加锁，执行效率会提高。 *缺点：类加载时就初始化，浪费内存。 *它基于 classloder 机制避免了多线程的同步问题，- 不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种， 在单例模式中大多数都是调用 getInstance 方法，- 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载， 这时候初始化 instance 显然没有达到 lazy loading 的效果。 */ private static SingletonEH instance = new SingletonEH(); private SingletonEH ()&#123;&#125; public static SingletonEH getInstance() &#123; System.out.println("instance:"+instance); System.out.println("加载饿汉式...."); return instance; &#125; &#125; 饿汉就是类一旦加载，就把单例初始化完成，保证getInstance的时候，单例是已经存在的了。 懒汉式 public class SingletonLH &#123; /** *是否 Lazy 初始化：是 *是否多线程安全：否 *实现难度：易 *描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。 *这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。 */ private static SingletonLH instance; private SingletonLH ()&#123;&#125; public static SingletonLH getInstance() &#123; if (instance == null) &#123; instance = new SingletonLH(); &#125; return instance; &#125;&#125; 而懒汉比较懒，只有当调用getInstance的时候，才回去初始化这个单例。 1、线程安全： 饿汉式天生就是线程安全的，可以直接用于多线程而不会出现问题， 懒汉式本身是非线程安全的，为了实现线程安全有几种写法。 例： public class SingletonLHsyn &#123; /** *是否 Lazy 初始化：是 *是否多线程安全：是 *实现难度：易 *描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。 *优点：第一次调用才初始化，避免内存浪费。 *缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。 *getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。 */ private static SingletonLHsyn instance; private SingletonLHsyn ()&#123;&#125; public static synchronized SingletonLHsyn getInstance() &#123; if (instance == null) &#123; instance = new SingletonLHsyn(); &#125; return instance; &#125;&#125; 2、资源加载和性能： 饿汉式在类创建的同时就实例化一个静态对象出来，不管之后会不会使用这个单例，都会占据一定的内存，但是相应的，在第一次调用时速度也会更快，因为其资源已经初始化完成。 而懒汉式顾名思义，会延迟加载，在第一次使用该单例的时候才会实例化对象出来，第一次调用时要做初始化，如果要做的工作比较多，性能上会有些延迟，之后就和饿汉式一样了。 意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 主要解决：一个全局使用的类频繁地创建与销毁。 何时使用：当您想控制实例数目，节省系统资源的时候。 如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。 关键代码：构造函数是私有的。 应用实例： 1、一个党只能有一个主席。 2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。 3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。 优点： 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 2、避免对资源的多重占用（比如写文件操作）。 缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。 使用场景： 1、要求生产唯一序列号。 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。 注意事项：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成instance 被多次实例化。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典递归问题：取球问题]]></title>
    <url>%2F2019%2F01%2F19%2F%E7%BB%8F%E5%85%B8%E9%80%92%E5%BD%92%E9%97%AE%E9%A2%98%EF%BC%9A%E5%8F%96%E7%90%83%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[【请先食用上一篇】：递归与循环 问：在n个球中，任意取出m个球(不放回)，求有多少种不同取法? 解法: import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class Main &#123; public static void main(String[] args) throws IOException &#123; BufferedReader scan=new BufferedReader(new InputStreamReader(System.in)); System.out.println("请输入球的总数："); int n=Integer.parseInt(scan.readLine()); System.out.println("请输入取出球的个数："); int m=Integer.parseInt(scan.readLine()); int count=f(n,m); System.out.println("在"+n+"个球中，任意取出"+m+"个球(不放回)，有:"+count+" 种不同取法"); &#125; private static int f(int n, int m) &#123; if(m &gt; n)&#123; return 0; &#125; if (n == m) &#123; return 1; &#125; if (m == 0) &#123; return 1; &#125; return f(n-1,m-1)+f(n-1,m); &#125;&#125; 运行截图： 思路： 【分析】： 递归问题，往往是将问题拆解成一个与原问题相似的问题+一个现阶段容易且能够解决的小部分，如图所示： 假设左边阶梯型图形为给出的问题，解法是转化为右边图形：将原问题拆解为与原问题相似的蓝色上部分以及现阶段容易且能够解决的绿色部分。 但有时候所给出的问题往往难以直接拆分，这类问题如同一个完美无缺的圆，突破口不易观察，很难直接将问题进行拆解，正如这道取球问题，这时就需要花点技巧。 【解决】： 我们假设n个球中有一个为幸运球，这时取球问题就出现了两种情况： 幸运球一定被取出:有了这个限定条件，相当于从n个球中拿出一个球(幸运球)事先放在取球者手中(这样才能保证幸运球一定被取出)，此时取球问题就变成了从n-1个球中取出m-1个球，即f(n-1,m-1)； 幸运球一定不被取出:有了这个限定条件，相当于从n个球中剔除出一个球(幸运球)，这样才能保证幸运球一定不被取出，此时取球问题就变成了从n-1个球中取出m个球，即f(n-1,m)； 综上，从n个球中取出m个球的总取法=取法1(幸运球被取出)+取法2(幸运球不被取出)=f(n-1,m-1)+f(n-1,m). 这便满足了递归问题两大要点之一:相似性，还需要满足另一要点:出口，如下： &gt; if (m &gt; n) return 0;//取球数&gt;总球数，不合理，终止递归&gt; &gt; &gt; 2. ~~~java&gt; if (n == m) return 1;//表示从x个球中取出x个球，只有一种取法&gt; &gt; if (m == 0) return 1;//表示从x个球中取出0个球，也是只有一种取法（即不取）&gt; &gt; &gt;]]></content>
      <categories>
        <category>每日一道编程题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>蓝桥杯</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单一步激活Office2019]]></title>
    <url>%2F2019%2F01%2F19%2F%E7%AE%80%E5%8D%95%E4%B8%80%E6%AD%A5%E6%BF%80%E6%B4%BBOffice2019%2F</url>
    <content type="text"><![CDATA[无需第三方破解软件 激活成功截图 激活方法新建文本文档，输入以下代码： @echo off(cd /d “%~dp0”)&amp;&amp;(NET FILE||(powershell start-process -FilePath ‘%0’ -verb runas)&amp;&amp;(exit /B)) &gt;NUL 2&gt;&amp;1title Office 2019 Activator r/Piracyecho Converting… &amp; mode 40,25(if exist “%ProgramFiles%\Microsoft Office\Office16\ospp.vbs” cd /d “%ProgramFiles%\Microsoft Office\Office16”)&amp;(if exist “%ProgramFiles(x86)%\Microsoft Office\Office16\ospp.vbs” cd /d “%ProgramFiles(x86)%\Microsoft Office\Office16”)&amp;(for /f %%x in (‘dir /b ..\root\Licenses16\ProPlus2019VL.xrm-ms’) do cscript ospp.vbs /inslic:”..\root\Licenses16\%%x” &gt;nul)&amp;(for /f %%x in (‘dir /b ..\root\Licenses16\ProPlus2019VL.xrm-ms’) do cscript ospp.vbs /inslic:”..\root\Licenses16\%%x” &gt;nul)cscript //nologo ospp.vbs /unpkey:6MWKP &gt;nul&amp;cscript //nologo ospp.vbs /inpkey:NMMKJ-6RK4F-KMJVX-8D9MJ-6MWKP &gt;nul&amp;set i=1:serverif %i%==1 set KMS_Sev=kms7.MSGuides.comif %i%==2 set KMS_Sev=kms8.MSGuides.comif %i%==3 set KMS_Sev=kms9.MSGuides.comcscript //nologo ospp.vbs /sethst:%KMS_Sev% &gt;nulecho %KMS_Sev% &amp; echo Activating…cscript //nologo ospp.vbs /act | find /i “successful” &amp;&amp; (echo Complete) || (echo Trying another KMS Server &amp; set /a i+=1 &amp; goto server)pause &gt;nulexit 保存之后，修改文本文档后缀，将.txt修改为.bat保持联网，然后以管理员身份运行，等待数秒，即可激活。本方法通过kms密钥管理服务器激活，有效期为180天，等到180天后，又会自动联网激活，不用重复操作，然后再续180天。]]></content>
      <categories>
        <category>杂文随笔</category>
      </categories>
      <tags>
        <tag>小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归与循环]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%80%92%E5%BD%92%E4%B8%8E%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[一.递归与循环递归，说白了就是自己调用自己。理论上，任何的循环都可以重写为递归形式，所有的递归也可以被表述成循环的形式，本文主要介绍如何将循环重写为递归。 二.循环改递归的两大要点 发现逻辑“相似性” 不要忘记递归的“出口” 小例子： public class demo&#123; public static void main(String[] args)&#123; for(int i=0;i&lt;10;i++)&#123; System.out.println(i); &#125; &#125;&#125; 上述代码的输出结果是打印出数字“0-9”。 这是利用循环实现，接下来我们将循环改写为递归： public class Main&#123; public static void f(int n)&#123; if(n&lt;0) return;//出口 f(n-1);//打印0 ~ n-1 System.out.println(n);//打印n &#125; public static void main(String[] args)&#123; f(9); &#125;&#125; 思路解释：“踢皮球”-常用来形容政府职能部门职责不清，相互推诿，比如你要到部门A盖个章，A叫你先去部门B盖章，B叫你去部门C盖章…这种将工作以踢皮球的方式甩给其他人做的方式其实很适用于递归。 但在递归中，如果你甩给其他人的工作和分配给你的工作完全一样，则程序陷入死循环，一直没有人进行工作，一直在甩锅，因此，递归中为：自己做一小部分事情，剩下的事情再甩给其他人去做。 我们要做的是打印除数字“0 - 9”，那么，我完全可以自己负责打印其中一个数（代码中表现为打印末尾数字9），将剩下的数字“0 - 8”交予其他人去打印，比如A打印9，B负责打印“0-8”，B又打印8,并将“0-7”甩给C去负责，C又打印7，剩下的甩给D…… 每次甩给下个人的工作都少了一点，在代码中表现为每次进行调用的参数都不一致，这就是发现逻辑“相似性”，每次调用的都是f(int n)这个方法，但每次参数都发生了变化，即f(n-1)。 但若一直递归下去，程序将陷入死循环，当n=0时，又会调用f(-1)，这显然不正确，因此，我们需要给递归加上一个出口限制，即if(n&lt;0) return;，当n&lt;0时，代表0~9都已经打印完毕，我们需要终止递归。 注：并不一定非得A打印9，将“0~8”甩给B…也可以A负责打印首位0，将“1~9”甩给B…这种情况有些许不一样（其实就是参数发生了变化）,代码如下： public static void f2(int begin,int end)&#123; if(begin&gt;end) return; System.out.println(begin); f2(begin+1,end);&#125; 由上可看出，循环转递归，可能并非只有一种解法，也可存在多种改写形式，但都遵循“相似性”+“出口”的原则。 三.构造相似性 如果没有明显的相似性，需要主动构造 不能相似的原因很可能是缺少参数 递归与数学上的递推公式很类似 在循环转递归的过程中，可能并不具有非常明显的相似性，很可能是因为缺少参数的原因，这时候就需要我们去主动构造相似性，通常为增加参数来实现。 例子1： public class demo&#123; public static int addAll(int[] a)&#123; int x=0; for(int i=0;i&lt;a.length;i++)&#123; x+=a[i]; &#125; return x; &#125; public static void main(String[] args)&#123; int[] a=&#123;3,4,11,8&#125;; int sum=addAll(a); System.out.println(sum); &#125;&#125; 上述代码的功能为将数组a中的所有元素求和并打印。接下来，将循环改写为递归： public class Main&#123; public static int f(int[] a,int begin)&#123; if(begin==a.length) return 0;//出口 int x=f(a,begin+1); return x+a[begin]; &#125; public static void main(String[] args)&#123; int[] a=&#123;3,4,11,8&#125;; int sum=f(a,0); System.out.println(sum); &#125;&#125; 转为递归求和，我们一开始想到的肯定是定义一个求和方法，方法内传入要求和的数组，即 f(int[] a) ,但这样踢皮球每次甩给别人的都是原封不动的任务，导致程序进入死循环，因此我们需要加入一个参数 int begin 作为当前对象负责求和的起始元素的下标，这样，A只需要将 begin+1~end 的求和工作甩给B去做，B只需要再将拿到的begin进行+1操作,然后甩给C去做……待B传回求和的值，A再将B传回的值加上a[0]就可以得到数组所有元素之和了。 注：除了上述解法之外，还有以下解法： [0……end-1] ［end］，将数组拆成两部分，A负责end，将0~end-1甩给B去做； 折半求和： public class Main&#123; public static int f(int[] a,int begin,int end)&#123; if(begin&gt;end) return 0; int middle = (begin+end)/2; //取中值 if(begin==end)&#123; return a[end]; &#125; return f(a,begin,middle)+f(a,middle+1,end); &#125; public static void main(String[] args)&#123; int[] a=&#123;3,4,11,8&#125;; int sum=f(a,0,a.length-1); System.out.println(sum); &#125;&#125; 例子2： public class demo&#123; public static boolean isSameString(String s1,String s2)&#123; return s1.equals(s2); &#125; public static void main(String[] args)&#123; System.out.println(isSameString("abc","abcd")); &#125;&#125; 上述代码的功能为比较两个字符串是否相同。接下来，将循环改写为递归： public class Main &#123; public static boolean f(String s1, String s2) &#123; if(s1.length()!=s2.length()) &#123; return false; &#125; if(s1.length()==0) &#123;//出口：当比较至两字符串为空时表示两字符串各字符均相同 return true; &#125; if(s1.charAt(0)!=s2.charAt(0)) &#123; return false; &#125; return f(s1.substring(1),s2.substring(1)); &#125; public static void main(String[] args) &#123; System.out.println(f("abc", "abcd")); &#125;&#125; 四.递归调用 递归调用仅仅是被调用函数恰为主调函数(自己调用自己) 注意每次调用的层次不同 注意每次分配形参并非同一个变量 注意返回的次序 如图所示：A运行到节点a，调用B，B运行到节点b，调用C，C执行结束之后，将结果返回节点b，B从节点b开始继续运行，B执行结束之后将结果返回节点a，A再从节点a开始继续运行… 该执行过程要求每一次节点中断调用其他方法，必须记录下该中断节点的环境信息，作用是为了调用结束返回结果之后原程序能够从上次中断位置起继续执行，在计算机中，通过一个栈结构来实现该效果(栈:先进后出)： A执行至a时将要去调用B，此时将节点a的环境信息通过压栈的方式保存在栈结构中，同理，在b节点处又将节点b的环境信息通过压栈的方式保存在栈结构中； 当C执行结束返回结果给B时，通过弹栈的方式将b进行出栈操作，这样B就可以从b开始继续运行，同理，当B执行完毕返回结果给A时，通过弹栈的方式将a进行出栈操作，这样A就可以从a开始继续运行。 逐层深入，逐层返回。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>蓝桥杯</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零基础学高数001：函数及其四种特性]]></title>
    <url>%2F2019%2F01%2F15%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E9%AB%98%E6%95%B0001%EF%BC%9A%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E5%9B%9B%E7%A7%8D%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[写在前面：从今天开始，开始准备考研数学之高等数学，受网上推荐基础薄弱适合看高昆轮老师的讲义视频，于是决定从高老师的视频讲义进入高数学习，将大一所学的高数知识捡起来，希望自己能够有所收获，也希望自己能够坚持到底，来年考上自己心仪的学校！ 函数的概念 注：定义域和对应法则是函数的两个基本要素，当且仅当两个函数的定义域以及对应法则都相同时，两个函数才是相同的。 函数的四种特性 有界性 单调性 理解单调不减和单调不增： 奇偶性 周期性]]></content>
      <categories>
        <category>数学</category>
        <category>考研</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
        <tag>考研复习</tag>
        <tag>高昆轮</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[StringBuilder、StringBuffer和String三者的联系和区别]]></title>
    <url>%2F2019%2F01%2F14%2FStringBuilder%E3%80%81StringBuffer%E5%92%8CString%E4%B8%89%E8%80%85%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[1.String类String的值是不可变的，这就导致每次对String的操作都会生成新的String对象，不仅效率低下，而且大量浪费有限的内存空间。 String a = "a"; //假设a指向地址0x0001 a = "b";//重新赋值后a指向地址0x0002，但0x0001地址中保存的"a"依旧存在，但已经不再是a所指向的,a 已经指向了其它地址。 因此String的操作都是改变赋值地址而不是改变值操作。 2.StringBuffer类StringBuffer是可变类，和线程安全的字符串操作类，任何对它指向的字符串的操作都不会产生新的对象。每个StringBuffer对象都有一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会自动增加容量。 StringBuffer buf=new StringBuffer(); //分配长16字节的字符缓冲区 StringBuffer buf=new StringBuffer(512); //分配长512字节的字符缓冲区 StringBuffer buf=new StringBuffer("this is a test")//在缓冲区中存放了字符串，并在后面预留了16字节的空缓冲区。 3.StringBuilder类StringBuilder和StringBuffer类功能基本相似，主要区别在于StringBuffer类的方法是多线程、安全的，而 StringBuilder不是线程安全的，相比而言，StringBuilder类会略微快一点。对于经常要改变值的字符串应该使用StringBuffer和StringBuilder类。 4.线程安全StringBuffer 线程安全StringBuilder 线程不安全 5.速度一般情况下,速度从快到慢:StringBuilder&gt;StringBuffer&gt;String,这种比较是相对的，不是绝对的。 6.总结 如果要操作少量的数据 用 String 单线程操作字符串缓冲区下操作大量数据 用 StringBuilder 多线程操作字符串缓冲区下操作大量数据 用 StringBuffer]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二维数组中查找]]></title>
    <url>%2F2019%2F01%2F08%2F%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[【问】：在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。public class Solution &#123;public static boolean Find(int target, int[][] array) &#123; ... &#125;&#125; 两种解法： 思路1： 把每一行看成有序递增的数组，利用二分查找，通过遍历每一行得到答案，时间复杂度是nlogn public static boolean Find(int target, int[][] array) &#123; boolean flag = false; for (int i = 0; i &lt; array.length; i++) &#123; int low = 0, high = array[0].length - 1; if (flag) &#123; break; &#125; while (low &lt;= high) &#123; int mid = (low + high) / 2; if (target &gt; array[i][mid]) &#123; low = mid + 1; &#125; if (target &lt; array[i][mid]) &#123; high = mid - 1; &#125; if (target == array[i][mid]) &#123; flag = true; break; &#125; &#125; &#125; return flag; &#125; 思路2： 利用二维数组由上到下，由左到右递增的规律，那么选取右上角或者左下角的元素num与target进行比较， 当target小于元素num时，那么target必定在元素a所在列的左边,即y- -； 当target大于元素num时，那么target必定在元素a所在行的下边,即x++； public static boolean Find(int target, int[][] array) &#123; int rowLen = array.length;// 行数 int x= 0;//位于第几行 int y = array[0].length;// 列数 &amp;&amp; 位于第几列 boolean flag = false; while (x &lt; rowLen &amp;&amp; y &gt;0) &#123; int num = array[x][y - 1]; if (target &lt; num) &#123; y--; &#125; if (target &gt; num) &#123; x++; &#125; if (target == num) &#123; flag = true; break; &#125; &#125; return flag; &#125;]]></content>
      <categories>
        <category>每日一道编程题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
</search>
